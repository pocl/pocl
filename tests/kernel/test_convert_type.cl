/* !!!! AUTOGENERATED FILE generated by test_convert_type.py !!!!!

   DO NOT CHANGE THIS FILE. MAKE YOUR CHANGES TO test_convert_type.py AND RUN:
   $ python3 test_convert_type.py > test_convert_type.cl
*/

constant char char_values[6] = { 0, 1, CHAR_MIN, CHAR_MAX, CHAR_MIN / 2, CHAR_MAX / 2 };
constant uchar uchar_values[6] = { 0, 1, 0, UCHAR_MAX, 0 / 2, UCHAR_MAX / 2 };
constant short short_values[6] = { 0, 1, SHRT_MIN, SHRT_MAX, SHRT_MIN / 2, SHRT_MAX / 2 };
constant ushort ushort_values[6] = { 0, 1, 0, USHRT_MAX, 0 / 2, USHRT_MAX / 2 };
constant int int_values[6] = { 0, 1, INT_MIN, INT_MAX, INT_MIN / 2, INT_MAX / 2 };
constant uint uint_values[6] = { 0, 1, 0, UINT_MAX, 0 / 2, UINT_MAX / 2 };

constant size_t char_values_length = sizeof(char_values) / sizeof(char_values[0]);
constant size_t uchar_values_length = sizeof(uchar_values) / sizeof(uchar_values[0]);
constant size_t short_values_length = sizeof(short_values) / sizeof(short_values[0]);
constant size_t ushort_values_length = sizeof(ushort_values) / sizeof(ushort_values[0]);
constant size_t int_values_length = sizeof(int_values) / sizeof(int_values[0]);
constant size_t uint_values_length = sizeof(uint_values) / sizeof(uint_values[0]);

#ifdef cles_khr_int64
constant long long_values[6] = { 0, 1, LONG_MIN, LONG_MAX, LONG_MIN / 2, LONG_MAX / 2 };
constant ulong ulong_values[6] = { 0, 1, 0, ULONG_MAX, 0 / 2, ULONG_MAX / 2 };

constant size_t long_values_length = sizeof(long_values) / sizeof(long_values[0]);
constant size_t ulong_values_length = sizeof(ulong_values) / sizeof(ulong_values[0]);

#endif

#ifdef cl_khr_fp64
constant float float_sat_offsets[16] =
{
   0.0f, (float)CHAR_MAX, (float)CHAR_MIN, (float)UCHAR_MAX, (float)SHRT_MIN, (float)SHRT_MAX, (float)USHRT_MAX, (float)INT_MAX,
   (float)INT_MIN, (float)UINT_MAX, (float)LONG_MAX, (float)LONG_MIN, (float)ULONG_MAX, 0.0f, 1.0e15f, -1.0e15f
};
#else
constant float float_sat_offsets[13] =
{
   0.0f, (float)CHAR_MAX, (float)CHAR_MIN, (float)UCHAR_MAX, (float)SHRT_MIN, (float)SHRT_MAX, (float)USHRT_MAX, (float)INT_MAX,
   (float)INT_MIN, (float)UINT_MAX, 0.0f, 1.0e15f, -1.0e15f
};
#endif

constant float float_values            [17] = { -2.0f, -1.75f, -1.5f, -1.25f, -1.0f, -0.75f, -0.5f, -0.25f, 0.0f, 0.25f, 0.5f, 0.75f, 1.0f, 1.25f, 1.5f, 1.75f, 2.0f };
constant int float_rounded_values    [17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant int float_rounded_values_rtz[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant int float_rounded_values_rte[17] = { -2     , -2      , -2     , -1      , -1     , -1      ,  0     ,  0      , 0     , 0      , 0     , 1      , 1     , 1      , 2     , 2      , 2      };
constant int float_rounded_values_rtp[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 1      , 1     , 1      , 1     , 2      , 2     , 2      , 2      };
constant int float_rounded_values_rtn[17] = { -2     , -2      , -2     , -2      , -1     , -1      , -1     , -1      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };

constant size_t float_values_length = sizeof(float_values) / sizeof(float_values[0]);


#ifdef cl_khr_fp64

#ifdef cl_khr_fp64
constant double double_sat_offsets[16] =
{
   0.0, (double)CHAR_MAX, (double)CHAR_MIN, (double)UCHAR_MAX, (double)SHRT_MIN, (double)SHRT_MAX, (double)USHRT_MAX, (double)INT_MAX,
   (double)INT_MIN, (double)UINT_MAX, (double)LONG_MAX, (double)LONG_MIN, (double)ULONG_MAX, 0.0, 1.0e15, -1.0e15
};
#else
constant double double_sat_offsets[13] =
{
   0.0, (double)CHAR_MAX, (double)CHAR_MIN, (double)UCHAR_MAX, (double)SHRT_MIN, (double)SHRT_MAX, (double)USHRT_MAX, (double)INT_MAX,
   (double)INT_MIN, (double)UINT_MAX, 0.0, 1.0e15, -1.0e15
};
#endif

constant double double_values            [17] = { -2.0, -1.75, -1.5, -1.25, -1.0, -0.75, -0.5, -0.25, 0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0 };
constant long double_rounded_values    [17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant long double_rounded_values_rtz[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant long double_rounded_values_rte[17] = { -2     , -2      , -2     , -1      , -1     , -1      ,  0     ,  0      , 0     , 0      , 0     , 1      , 1     , 1      , 2     , 2      , 2      };
constant long double_rounded_values_rtp[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 1      , 1     , 1      , 1     , 2      , 2     , 2      , 2      };
constant long double_rounded_values_rtn[17] = { -2     , -2      , -2     , -2      , -1     , -1      , -1     , -1      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };

constant size_t double_values_length = sizeof(double_values) / sizeof(double_values[0]);


#endif

_CL_NOINLINE
void compare_char_elements(char const* name, size_t sample, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

_CL_NOINLINE
void compare_uchar_elements(char const* name, size_t sample, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

_CL_NOINLINE
void compare_short_elements(char const* name, size_t sample, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

_CL_NOINLINE
void compare_ushort_elements(char const* name, size_t sample, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

_CL_NOINLINE
void compare_int_elements(char const* name, size_t sample, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

_CL_NOINLINE
void compare_uint_elements(char const* name, size_t sample, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

#ifdef cles_khr_int64

_CL_NOINLINE
void compare_long_elements(char const* name, size_t sample, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.16lx actual: %#.16lx\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

#endif

#ifdef cles_khr_int64

_CL_NOINLINE
void compare_ulong_elements(char const* name, size_t sample, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %#.16lx actual: %#.16lx\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

#endif

_CL_NOINLINE
void compare_float_elements(char const* name, size_t sample, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %.12g actual: %.12g\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements(char const* name, size_t sample, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u expected: %.18g actual: %.18g\n",
        name, (uint)sample, (uint)i, expected[i], actual[i]);
      break;
    }
  }
}

#endif

kernel void test_convert_type()
{
  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (CHAR_MIN > CHAR_MIN) ? (char)CHAR_MIN : CHAR_MIN;
    const char max_expected = (CHAR_MAX < CHAR_MAX) ? (char)CHAR_MAX : CHAR_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)char_values[i]));
    actual.value = convert_char((char)char_values[i]);
    compare_char_elements("convert_char((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((char)char_values[i]);
    compare_char_elements("convert_char_sat((char))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (CHAR_MIN > CHAR_MIN) ? (char)CHAR_MIN : CHAR_MIN;
    const char max_expected = (CHAR_MAX < CHAR_MAX) ? (char)CHAR_MAX : CHAR_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)char_values[i]));
    actual.value = convert_char2((char2)char_values[i]);
    compare_char_elements("convert_char2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((char2)char_values[i]);
    compare_char_elements("convert_char2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (CHAR_MIN > CHAR_MIN) ? (char)CHAR_MIN : CHAR_MIN;
    const char max_expected = (CHAR_MAX < CHAR_MAX) ? (char)CHAR_MAX : CHAR_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)char_values[i]));
    actual.value = convert_char4((char4)char_values[i]);
    compare_char_elements("convert_char4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((char4)char_values[i]);
    compare_char_elements("convert_char4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (CHAR_MIN > CHAR_MIN) ? (char)CHAR_MIN : CHAR_MIN;
    const char max_expected = (CHAR_MAX < CHAR_MAX) ? (char)CHAR_MAX : CHAR_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)char_values[i]));
    actual.value = convert_char8((char8)char_values[i]);
    compare_char_elements("convert_char8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((char8)char_values[i]);
    compare_char_elements("convert_char8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (CHAR_MIN > CHAR_MIN) ? (char)CHAR_MIN : CHAR_MIN;
    const char max_expected = (CHAR_MAX < CHAR_MAX) ? (char)CHAR_MAX : CHAR_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)char_values[i]));
    actual.value = convert_char16((char16)char_values[i]);
    compare_char_elements("convert_char16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((char16)char_values[i]);
    compare_char_elements("convert_char16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UCHAR_MAX < CHAR_MAX) ? (char)UCHAR_MAX : CHAR_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)char_values[i]));
    actual.value = convert_uchar((char)char_values[i]);
    compare_uchar_elements("convert_uchar((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((char)char_values[i]);
    compare_uchar_elements("convert_uchar_sat((char))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UCHAR_MAX < CHAR_MAX) ? (char)UCHAR_MAX : CHAR_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)char_values[i]));
    actual.value = convert_uchar2((char2)char_values[i]);
    compare_uchar_elements("convert_uchar2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((char2)char_values[i]);
    compare_uchar_elements("convert_uchar2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UCHAR_MAX < CHAR_MAX) ? (char)UCHAR_MAX : CHAR_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)char_values[i]));
    actual.value = convert_uchar4((char4)char_values[i]);
    compare_uchar_elements("convert_uchar4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((char4)char_values[i]);
    compare_uchar_elements("convert_uchar4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UCHAR_MAX < CHAR_MAX) ? (char)UCHAR_MAX : CHAR_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)char_values[i]));
    actual.value = convert_uchar8((char8)char_values[i]);
    compare_uchar_elements("convert_uchar8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((char8)char_values[i]);
    compare_uchar_elements("convert_uchar8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UCHAR_MAX < CHAR_MAX) ? (char)UCHAR_MAX : CHAR_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)char_values[i]));
    actual.value = convert_uchar16((char16)char_values[i]);
    compare_uchar_elements("convert_uchar16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((char16)char_values[i]);
    compare_uchar_elements("convert_uchar16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (SHRT_MIN > CHAR_MIN) ? (char)SHRT_MIN : CHAR_MIN;
    const char max_expected = (SHRT_MAX < CHAR_MAX) ? (char)SHRT_MAX : CHAR_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)char_values[i]));
    actual.value = convert_short((char)char_values[i]);
    compare_short_elements("convert_short((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((char)char_values[i]);
    compare_short_elements("convert_short_sat((char))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (SHRT_MIN > CHAR_MIN) ? (char)SHRT_MIN : CHAR_MIN;
    const char max_expected = (SHRT_MAX < CHAR_MAX) ? (char)SHRT_MAX : CHAR_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)char_values[i]));
    actual.value = convert_short2((char2)char_values[i]);
    compare_short_elements("convert_short2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((char2)char_values[i]);
    compare_short_elements("convert_short2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (SHRT_MIN > CHAR_MIN) ? (char)SHRT_MIN : CHAR_MIN;
    const char max_expected = (SHRT_MAX < CHAR_MAX) ? (char)SHRT_MAX : CHAR_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)char_values[i]));
    actual.value = convert_short4((char4)char_values[i]);
    compare_short_elements("convert_short4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((char4)char_values[i]);
    compare_short_elements("convert_short4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (SHRT_MIN > CHAR_MIN) ? (char)SHRT_MIN : CHAR_MIN;
    const char max_expected = (SHRT_MAX < CHAR_MAX) ? (char)SHRT_MAX : CHAR_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)char_values[i]));
    actual.value = convert_short8((char8)char_values[i]);
    compare_short_elements("convert_short8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((char8)char_values[i]);
    compare_short_elements("convert_short8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (SHRT_MIN > CHAR_MIN) ? (char)SHRT_MIN : CHAR_MIN;
    const char max_expected = (SHRT_MAX < CHAR_MAX) ? (char)SHRT_MAX : CHAR_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)char_values[i]));
    actual.value = convert_short16((char16)char_values[i]);
    compare_short_elements("convert_short16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((char16)char_values[i]);
    compare_short_elements("convert_short16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (USHRT_MAX < CHAR_MAX) ? (char)USHRT_MAX : CHAR_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)char_values[i]));
    actual.value = convert_ushort((char)char_values[i]);
    compare_ushort_elements("convert_ushort((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((char)char_values[i]);
    compare_ushort_elements("convert_ushort_sat((char))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (USHRT_MAX < CHAR_MAX) ? (char)USHRT_MAX : CHAR_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)char_values[i]));
    actual.value = convert_ushort2((char2)char_values[i]);
    compare_ushort_elements("convert_ushort2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((char2)char_values[i]);
    compare_ushort_elements("convert_ushort2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (USHRT_MAX < CHAR_MAX) ? (char)USHRT_MAX : CHAR_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)char_values[i]));
    actual.value = convert_ushort4((char4)char_values[i]);
    compare_ushort_elements("convert_ushort4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((char4)char_values[i]);
    compare_ushort_elements("convert_ushort4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (USHRT_MAX < CHAR_MAX) ? (char)USHRT_MAX : CHAR_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)char_values[i]));
    actual.value = convert_ushort8((char8)char_values[i]);
    compare_ushort_elements("convert_ushort8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((char8)char_values[i]);
    compare_ushort_elements("convert_ushort8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (USHRT_MAX < CHAR_MAX) ? (char)USHRT_MAX : CHAR_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)char_values[i]));
    actual.value = convert_ushort16((char16)char_values[i]);
    compare_ushort_elements("convert_ushort16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((char16)char_values[i]);
    compare_ushort_elements("convert_ushort16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (INT_MIN > CHAR_MIN) ? (char)INT_MIN : CHAR_MIN;
    const char max_expected = (INT_MAX < CHAR_MAX) ? (char)INT_MAX : CHAR_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)char_values[i]));
    actual.value = convert_int((char)char_values[i]);
    compare_int_elements("convert_int((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((char)char_values[i]);
    compare_int_elements("convert_int_sat((char))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (INT_MIN > CHAR_MIN) ? (char)INT_MIN : CHAR_MIN;
    const char max_expected = (INT_MAX < CHAR_MAX) ? (char)INT_MAX : CHAR_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)char_values[i]));
    actual.value = convert_int2((char2)char_values[i]);
    compare_int_elements("convert_int2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((char2)char_values[i]);
    compare_int_elements("convert_int2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (INT_MIN > CHAR_MIN) ? (char)INT_MIN : CHAR_MIN;
    const char max_expected = (INT_MAX < CHAR_MAX) ? (char)INT_MAX : CHAR_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)char_values[i]));
    actual.value = convert_int4((char4)char_values[i]);
    compare_int_elements("convert_int4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((char4)char_values[i]);
    compare_int_elements("convert_int4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (INT_MIN > CHAR_MIN) ? (char)INT_MIN : CHAR_MIN;
    const char max_expected = (INT_MAX < CHAR_MAX) ? (char)INT_MAX : CHAR_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)char_values[i]));
    actual.value = convert_int8((char8)char_values[i]);
    compare_int_elements("convert_int8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((char8)char_values[i]);
    compare_int_elements("convert_int8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (INT_MIN > CHAR_MIN) ? (char)INT_MIN : CHAR_MIN;
    const char max_expected = (INT_MAX < CHAR_MAX) ? (char)INT_MAX : CHAR_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)char_values[i]));
    actual.value = convert_int16((char16)char_values[i]);
    compare_int_elements("convert_int16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((char16)char_values[i]);
    compare_int_elements("convert_int16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UINT_MAX < CHAR_MAX) ? (char)UINT_MAX : CHAR_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)char_values[i]));
    actual.value = convert_uint((char)char_values[i]);
    compare_uint_elements("convert_uint((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((char)char_values[i]);
    compare_uint_elements("convert_uint_sat((char))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UINT_MAX < CHAR_MAX) ? (char)UINT_MAX : CHAR_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)char_values[i]));
    actual.value = convert_uint2((char2)char_values[i]);
    compare_uint_elements("convert_uint2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((char2)char_values[i]);
    compare_uint_elements("convert_uint2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UINT_MAX < CHAR_MAX) ? (char)UINT_MAX : CHAR_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)char_values[i]));
    actual.value = convert_uint4((char4)char_values[i]);
    compare_uint_elements("convert_uint4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((char4)char_values[i]);
    compare_uint_elements("convert_uint4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UINT_MAX < CHAR_MAX) ? (char)UINT_MAX : CHAR_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)char_values[i]));
    actual.value = convert_uint8((char8)char_values[i]);
    compare_uint_elements("convert_uint8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((char8)char_values[i]);
    compare_uint_elements("convert_uint8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (UINT_MAX < CHAR_MAX) ? (char)UINT_MAX : CHAR_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)char_values[i]));
    actual.value = convert_uint16((char16)char_values[i]);
    compare_uint_elements("convert_uint16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((char16)char_values[i]);
    compare_uint_elements("convert_uint16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (LONG_MIN > CHAR_MIN) ? (char)LONG_MIN : CHAR_MIN;
    const char max_expected = (LONG_MAX < CHAR_MAX) ? (char)LONG_MAX : CHAR_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)char_values[i]));
    actual.value = convert_long((char)char_values[i]);
    compare_long_elements("convert_long((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((char)char_values[i]);
    compare_long_elements("convert_long_sat((char))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (LONG_MIN > CHAR_MIN) ? (char)LONG_MIN : CHAR_MIN;
    const char max_expected = (LONG_MAX < CHAR_MAX) ? (char)LONG_MAX : CHAR_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)char_values[i]));
    actual.value = convert_long2((char2)char_values[i]);
    compare_long_elements("convert_long2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((char2)char_values[i]);
    compare_long_elements("convert_long2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (LONG_MIN > CHAR_MIN) ? (char)LONG_MIN : CHAR_MIN;
    const char max_expected = (LONG_MAX < CHAR_MAX) ? (char)LONG_MAX : CHAR_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)char_values[i]));
    actual.value = convert_long4((char4)char_values[i]);
    compare_long_elements("convert_long4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((char4)char_values[i]);
    compare_long_elements("convert_long4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (LONG_MIN > CHAR_MIN) ? (char)LONG_MIN : CHAR_MIN;
    const char max_expected = (LONG_MAX < CHAR_MAX) ? (char)LONG_MAX : CHAR_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)char_values[i]));
    actual.value = convert_long8((char8)char_values[i]);
    compare_long_elements("convert_long8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((char8)char_values[i]);
    compare_long_elements("convert_long8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (LONG_MIN > CHAR_MIN) ? (char)LONG_MIN : CHAR_MIN;
    const char max_expected = (LONG_MAX < CHAR_MAX) ? (char)LONG_MAX : CHAR_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)char_values[i]));
    actual.value = convert_long16((char16)char_values[i]);
    compare_long_elements("convert_long16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((char16)char_values[i]);
    compare_long_elements("convert_long16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (ULONG_MAX < CHAR_MAX) ? (char)ULONG_MAX : CHAR_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)char_values[i]));
    actual.value = convert_ulong((char)char_values[i]);
    compare_ulong_elements("convert_ulong((char))", i, expected.raw, actual.raw, 1);
    if (char_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((char)char_values[i]);
    compare_ulong_elements("convert_ulong_sat((char))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (ULONG_MAX < CHAR_MAX) ? (char)ULONG_MAX : CHAR_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)char_values[i]));
    actual.value = convert_ulong2((char2)char_values[i]);
    compare_ulong_elements("convert_ulong2((char2))", i, expected.raw, actual.raw, 2);
    if (char_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((char2)char_values[i]);
    compare_ulong_elements("convert_ulong2_sat((char2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (ULONG_MAX < CHAR_MAX) ? (char)ULONG_MAX : CHAR_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)char_values[i]));
    actual.value = convert_ulong4((char4)char_values[i]);
    compare_ulong_elements("convert_ulong4((char4))", i, expected.raw, actual.raw, 4);
    if (char_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((char4)char_values[i]);
    compare_ulong_elements("convert_ulong4_sat((char4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (ULONG_MAX < CHAR_MAX) ? (char)ULONG_MAX : CHAR_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)char_values[i]));
    actual.value = convert_ulong8((char8)char_values[i]);
    compare_ulong_elements("convert_ulong8((char8))", i, expected.raw, actual.raw, 8);
    if (char_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((char8)char_values[i]);
    compare_ulong_elements("convert_ulong8_sat((char8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (ULONG_MAX < CHAR_MAX) ? (char)ULONG_MAX : CHAR_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)char_values[i]));
    actual.value = convert_ulong16((char16)char_values[i]);
    compare_ulong_elements("convert_ulong16((char16))", i, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((char16)char_values[i]);
    compare_ulong_elements("convert_ulong16_sat((char16))", i, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (CHAR_MIN > 0) ? (uchar)CHAR_MIN : 0;
    const uchar max_expected = (CHAR_MAX < UCHAR_MAX) ? (uchar)CHAR_MAX : UCHAR_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)uchar_values[i]));
    actual.value = convert_char((uchar)uchar_values[i]);
    compare_char_elements("convert_char((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((uchar)uchar_values[i]);
    compare_char_elements("convert_char_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (CHAR_MIN > 0) ? (uchar)CHAR_MIN : 0;
    const uchar max_expected = (CHAR_MAX < UCHAR_MAX) ? (uchar)CHAR_MAX : UCHAR_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)uchar_values[i]));
    actual.value = convert_char2((uchar2)uchar_values[i]);
    compare_char_elements("convert_char2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((uchar2)uchar_values[i]);
    compare_char_elements("convert_char2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (CHAR_MIN > 0) ? (uchar)CHAR_MIN : 0;
    const uchar max_expected = (CHAR_MAX < UCHAR_MAX) ? (uchar)CHAR_MAX : UCHAR_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)uchar_values[i]));
    actual.value = convert_char4((uchar4)uchar_values[i]);
    compare_char_elements("convert_char4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((uchar4)uchar_values[i]);
    compare_char_elements("convert_char4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (CHAR_MIN > 0) ? (uchar)CHAR_MIN : 0;
    const uchar max_expected = (CHAR_MAX < UCHAR_MAX) ? (uchar)CHAR_MAX : UCHAR_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)uchar_values[i]));
    actual.value = convert_char8((uchar8)uchar_values[i]);
    compare_char_elements("convert_char8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((uchar8)uchar_values[i]);
    compare_char_elements("convert_char8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (CHAR_MIN > 0) ? (uchar)CHAR_MIN : 0;
    const uchar max_expected = (CHAR_MAX < UCHAR_MAX) ? (uchar)CHAR_MAX : UCHAR_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)uchar_values[i]));
    actual.value = convert_char16((uchar16)uchar_values[i]);
    compare_char_elements("convert_char16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((uchar16)uchar_values[i]);
    compare_char_elements("convert_char16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UCHAR_MAX < UCHAR_MAX) ? (uchar)UCHAR_MAX : UCHAR_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)uchar_values[i]));
    actual.value = convert_uchar((uchar)uchar_values[i]);
    compare_uchar_elements("convert_uchar((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((uchar)uchar_values[i]);
    compare_uchar_elements("convert_uchar_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UCHAR_MAX < UCHAR_MAX) ? (uchar)UCHAR_MAX : UCHAR_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)uchar_values[i]));
    actual.value = convert_uchar2((uchar2)uchar_values[i]);
    compare_uchar_elements("convert_uchar2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((uchar2)uchar_values[i]);
    compare_uchar_elements("convert_uchar2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UCHAR_MAX < UCHAR_MAX) ? (uchar)UCHAR_MAX : UCHAR_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)uchar_values[i]));
    actual.value = convert_uchar4((uchar4)uchar_values[i]);
    compare_uchar_elements("convert_uchar4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((uchar4)uchar_values[i]);
    compare_uchar_elements("convert_uchar4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UCHAR_MAX < UCHAR_MAX) ? (uchar)UCHAR_MAX : UCHAR_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)uchar_values[i]));
    actual.value = convert_uchar8((uchar8)uchar_values[i]);
    compare_uchar_elements("convert_uchar8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((uchar8)uchar_values[i]);
    compare_uchar_elements("convert_uchar8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UCHAR_MAX < UCHAR_MAX) ? (uchar)UCHAR_MAX : UCHAR_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)uchar_values[i]));
    actual.value = convert_uchar16((uchar16)uchar_values[i]);
    compare_uchar_elements("convert_uchar16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((uchar16)uchar_values[i]);
    compare_uchar_elements("convert_uchar16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (SHRT_MIN > 0) ? (uchar)SHRT_MIN : 0;
    const uchar max_expected = (SHRT_MAX < UCHAR_MAX) ? (uchar)SHRT_MAX : UCHAR_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)uchar_values[i]));
    actual.value = convert_short((uchar)uchar_values[i]);
    compare_short_elements("convert_short((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((uchar)uchar_values[i]);
    compare_short_elements("convert_short_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (SHRT_MIN > 0) ? (uchar)SHRT_MIN : 0;
    const uchar max_expected = (SHRT_MAX < UCHAR_MAX) ? (uchar)SHRT_MAX : UCHAR_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)uchar_values[i]));
    actual.value = convert_short2((uchar2)uchar_values[i]);
    compare_short_elements("convert_short2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((uchar2)uchar_values[i]);
    compare_short_elements("convert_short2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (SHRT_MIN > 0) ? (uchar)SHRT_MIN : 0;
    const uchar max_expected = (SHRT_MAX < UCHAR_MAX) ? (uchar)SHRT_MAX : UCHAR_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)uchar_values[i]));
    actual.value = convert_short4((uchar4)uchar_values[i]);
    compare_short_elements("convert_short4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((uchar4)uchar_values[i]);
    compare_short_elements("convert_short4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (SHRT_MIN > 0) ? (uchar)SHRT_MIN : 0;
    const uchar max_expected = (SHRT_MAX < UCHAR_MAX) ? (uchar)SHRT_MAX : UCHAR_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)uchar_values[i]));
    actual.value = convert_short8((uchar8)uchar_values[i]);
    compare_short_elements("convert_short8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((uchar8)uchar_values[i]);
    compare_short_elements("convert_short8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (SHRT_MIN > 0) ? (uchar)SHRT_MIN : 0;
    const uchar max_expected = (SHRT_MAX < UCHAR_MAX) ? (uchar)SHRT_MAX : UCHAR_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)uchar_values[i]));
    actual.value = convert_short16((uchar16)uchar_values[i]);
    compare_short_elements("convert_short16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((uchar16)uchar_values[i]);
    compare_short_elements("convert_short16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (USHRT_MAX < UCHAR_MAX) ? (uchar)USHRT_MAX : UCHAR_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)uchar_values[i]));
    actual.value = convert_ushort((uchar)uchar_values[i]);
    compare_ushort_elements("convert_ushort((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((uchar)uchar_values[i]);
    compare_ushort_elements("convert_ushort_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (USHRT_MAX < UCHAR_MAX) ? (uchar)USHRT_MAX : UCHAR_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)uchar_values[i]));
    actual.value = convert_ushort2((uchar2)uchar_values[i]);
    compare_ushort_elements("convert_ushort2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((uchar2)uchar_values[i]);
    compare_ushort_elements("convert_ushort2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (USHRT_MAX < UCHAR_MAX) ? (uchar)USHRT_MAX : UCHAR_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)uchar_values[i]));
    actual.value = convert_ushort4((uchar4)uchar_values[i]);
    compare_ushort_elements("convert_ushort4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((uchar4)uchar_values[i]);
    compare_ushort_elements("convert_ushort4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (USHRT_MAX < UCHAR_MAX) ? (uchar)USHRT_MAX : UCHAR_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)uchar_values[i]));
    actual.value = convert_ushort8((uchar8)uchar_values[i]);
    compare_ushort_elements("convert_ushort8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((uchar8)uchar_values[i]);
    compare_ushort_elements("convert_ushort8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (USHRT_MAX < UCHAR_MAX) ? (uchar)USHRT_MAX : UCHAR_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)uchar_values[i]));
    actual.value = convert_ushort16((uchar16)uchar_values[i]);
    compare_ushort_elements("convert_ushort16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((uchar16)uchar_values[i]);
    compare_ushort_elements("convert_ushort16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (INT_MIN > 0) ? (uchar)INT_MIN : 0;
    const uchar max_expected = (INT_MAX < UCHAR_MAX) ? (uchar)INT_MAX : UCHAR_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)uchar_values[i]));
    actual.value = convert_int((uchar)uchar_values[i]);
    compare_int_elements("convert_int((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((uchar)uchar_values[i]);
    compare_int_elements("convert_int_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (INT_MIN > 0) ? (uchar)INT_MIN : 0;
    const uchar max_expected = (INT_MAX < UCHAR_MAX) ? (uchar)INT_MAX : UCHAR_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)uchar_values[i]));
    actual.value = convert_int2((uchar2)uchar_values[i]);
    compare_int_elements("convert_int2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((uchar2)uchar_values[i]);
    compare_int_elements("convert_int2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (INT_MIN > 0) ? (uchar)INT_MIN : 0;
    const uchar max_expected = (INT_MAX < UCHAR_MAX) ? (uchar)INT_MAX : UCHAR_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)uchar_values[i]));
    actual.value = convert_int4((uchar4)uchar_values[i]);
    compare_int_elements("convert_int4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((uchar4)uchar_values[i]);
    compare_int_elements("convert_int4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (INT_MIN > 0) ? (uchar)INT_MIN : 0;
    const uchar max_expected = (INT_MAX < UCHAR_MAX) ? (uchar)INT_MAX : UCHAR_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)uchar_values[i]));
    actual.value = convert_int8((uchar8)uchar_values[i]);
    compare_int_elements("convert_int8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((uchar8)uchar_values[i]);
    compare_int_elements("convert_int8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (INT_MIN > 0) ? (uchar)INT_MIN : 0;
    const uchar max_expected = (INT_MAX < UCHAR_MAX) ? (uchar)INT_MAX : UCHAR_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)uchar_values[i]));
    actual.value = convert_int16((uchar16)uchar_values[i]);
    compare_int_elements("convert_int16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((uchar16)uchar_values[i]);
    compare_int_elements("convert_int16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UINT_MAX < UCHAR_MAX) ? (uchar)UINT_MAX : UCHAR_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)uchar_values[i]));
    actual.value = convert_uint((uchar)uchar_values[i]);
    compare_uint_elements("convert_uint((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((uchar)uchar_values[i]);
    compare_uint_elements("convert_uint_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UINT_MAX < UCHAR_MAX) ? (uchar)UINT_MAX : UCHAR_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)uchar_values[i]));
    actual.value = convert_uint2((uchar2)uchar_values[i]);
    compare_uint_elements("convert_uint2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((uchar2)uchar_values[i]);
    compare_uint_elements("convert_uint2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UINT_MAX < UCHAR_MAX) ? (uchar)UINT_MAX : UCHAR_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)uchar_values[i]));
    actual.value = convert_uint4((uchar4)uchar_values[i]);
    compare_uint_elements("convert_uint4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((uchar4)uchar_values[i]);
    compare_uint_elements("convert_uint4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UINT_MAX < UCHAR_MAX) ? (uchar)UINT_MAX : UCHAR_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)uchar_values[i]));
    actual.value = convert_uint8((uchar8)uchar_values[i]);
    compare_uint_elements("convert_uint8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((uchar8)uchar_values[i]);
    compare_uint_elements("convert_uint8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (UINT_MAX < UCHAR_MAX) ? (uchar)UINT_MAX : UCHAR_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)uchar_values[i]));
    actual.value = convert_uint16((uchar16)uchar_values[i]);
    compare_uint_elements("convert_uint16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((uchar16)uchar_values[i]);
    compare_uint_elements("convert_uint16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (LONG_MIN > 0) ? (uchar)LONG_MIN : 0;
    const uchar max_expected = (LONG_MAX < UCHAR_MAX) ? (uchar)LONG_MAX : UCHAR_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)uchar_values[i]));
    actual.value = convert_long((uchar)uchar_values[i]);
    compare_long_elements("convert_long((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((uchar)uchar_values[i]);
    compare_long_elements("convert_long_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (LONG_MIN > 0) ? (uchar)LONG_MIN : 0;
    const uchar max_expected = (LONG_MAX < UCHAR_MAX) ? (uchar)LONG_MAX : UCHAR_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)uchar_values[i]));
    actual.value = convert_long2((uchar2)uchar_values[i]);
    compare_long_elements("convert_long2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((uchar2)uchar_values[i]);
    compare_long_elements("convert_long2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (LONG_MIN > 0) ? (uchar)LONG_MIN : 0;
    const uchar max_expected = (LONG_MAX < UCHAR_MAX) ? (uchar)LONG_MAX : UCHAR_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)uchar_values[i]));
    actual.value = convert_long4((uchar4)uchar_values[i]);
    compare_long_elements("convert_long4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((uchar4)uchar_values[i]);
    compare_long_elements("convert_long4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (LONG_MIN > 0) ? (uchar)LONG_MIN : 0;
    const uchar max_expected = (LONG_MAX < UCHAR_MAX) ? (uchar)LONG_MAX : UCHAR_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)uchar_values[i]));
    actual.value = convert_long8((uchar8)uchar_values[i]);
    compare_long_elements("convert_long8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((uchar8)uchar_values[i]);
    compare_long_elements("convert_long8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (LONG_MIN > 0) ? (uchar)LONG_MIN : 0;
    const uchar max_expected = (LONG_MAX < UCHAR_MAX) ? (uchar)LONG_MAX : UCHAR_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)uchar_values[i]));
    actual.value = convert_long16((uchar16)uchar_values[i]);
    compare_long_elements("convert_long16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((uchar16)uchar_values[i]);
    compare_long_elements("convert_long16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (ULONG_MAX < UCHAR_MAX) ? (uchar)ULONG_MAX : UCHAR_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)uchar_values[i]));
    actual.value = convert_ulong((uchar)uchar_values[i]);
    compare_ulong_elements("convert_ulong((uchar))", i, expected.raw, actual.raw, 1);
    if (uchar_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((uchar)uchar_values[i]);
    compare_ulong_elements("convert_ulong_sat((uchar))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (ULONG_MAX < UCHAR_MAX) ? (uchar)ULONG_MAX : UCHAR_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)uchar_values[i]));
    actual.value = convert_ulong2((uchar2)uchar_values[i]);
    compare_ulong_elements("convert_ulong2((uchar2))", i, expected.raw, actual.raw, 2);
    if (uchar_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((uchar2)uchar_values[i]);
    compare_ulong_elements("convert_ulong2_sat((uchar2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (ULONG_MAX < UCHAR_MAX) ? (uchar)ULONG_MAX : UCHAR_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)uchar_values[i]));
    actual.value = convert_ulong4((uchar4)uchar_values[i]);
    compare_ulong_elements("convert_ulong4((uchar4))", i, expected.raw, actual.raw, 4);
    if (uchar_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((uchar4)uchar_values[i]);
    compare_ulong_elements("convert_ulong4_sat((uchar4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (ULONG_MAX < UCHAR_MAX) ? (uchar)ULONG_MAX : UCHAR_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)uchar_values[i]));
    actual.value = convert_ulong8((uchar8)uchar_values[i]);
    compare_ulong_elements("convert_ulong8((uchar8))", i, expected.raw, actual.raw, 8);
    if (uchar_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((uchar8)uchar_values[i]);
    compare_ulong_elements("convert_ulong8_sat((uchar8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (ULONG_MAX < UCHAR_MAX) ? (uchar)ULONG_MAX : UCHAR_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)uchar_values[i]));
    actual.value = convert_ulong16((uchar16)uchar_values[i]);
    compare_ulong_elements("convert_ulong16((uchar16))", i, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((uchar16)uchar_values[i]);
    compare_ulong_elements("convert_ulong16_sat((uchar16))", i, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (CHAR_MIN > SHRT_MIN) ? (short)CHAR_MIN : SHRT_MIN;
    const short max_expected = (CHAR_MAX < SHRT_MAX) ? (short)CHAR_MAX : SHRT_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)short_values[i]));
    actual.value = convert_char((short)short_values[i]);
    compare_char_elements("convert_char((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((short)short_values[i]);
    compare_char_elements("convert_char_sat((short))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (CHAR_MIN > SHRT_MIN) ? (short)CHAR_MIN : SHRT_MIN;
    const short max_expected = (CHAR_MAX < SHRT_MAX) ? (short)CHAR_MAX : SHRT_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)short_values[i]));
    actual.value = convert_char2((short2)short_values[i]);
    compare_char_elements("convert_char2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((short2)short_values[i]);
    compare_char_elements("convert_char2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (CHAR_MIN > SHRT_MIN) ? (short)CHAR_MIN : SHRT_MIN;
    const short max_expected = (CHAR_MAX < SHRT_MAX) ? (short)CHAR_MAX : SHRT_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)short_values[i]));
    actual.value = convert_char4((short4)short_values[i]);
    compare_char_elements("convert_char4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((short4)short_values[i]);
    compare_char_elements("convert_char4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (CHAR_MIN > SHRT_MIN) ? (short)CHAR_MIN : SHRT_MIN;
    const short max_expected = (CHAR_MAX < SHRT_MAX) ? (short)CHAR_MAX : SHRT_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)short_values[i]));
    actual.value = convert_char8((short8)short_values[i]);
    compare_char_elements("convert_char8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((short8)short_values[i]);
    compare_char_elements("convert_char8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (CHAR_MIN > SHRT_MIN) ? (short)CHAR_MIN : SHRT_MIN;
    const short max_expected = (CHAR_MAX < SHRT_MAX) ? (short)CHAR_MAX : SHRT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)short_values[i]));
    actual.value = convert_char16((short16)short_values[i]);
    compare_char_elements("convert_char16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((short16)short_values[i]);
    compare_char_elements("convert_char16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UCHAR_MAX < SHRT_MAX) ? (short)UCHAR_MAX : SHRT_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)short_values[i]));
    actual.value = convert_uchar((short)short_values[i]);
    compare_uchar_elements("convert_uchar((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((short)short_values[i]);
    compare_uchar_elements("convert_uchar_sat((short))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UCHAR_MAX < SHRT_MAX) ? (short)UCHAR_MAX : SHRT_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)short_values[i]));
    actual.value = convert_uchar2((short2)short_values[i]);
    compare_uchar_elements("convert_uchar2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((short2)short_values[i]);
    compare_uchar_elements("convert_uchar2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UCHAR_MAX < SHRT_MAX) ? (short)UCHAR_MAX : SHRT_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)short_values[i]));
    actual.value = convert_uchar4((short4)short_values[i]);
    compare_uchar_elements("convert_uchar4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((short4)short_values[i]);
    compare_uchar_elements("convert_uchar4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UCHAR_MAX < SHRT_MAX) ? (short)UCHAR_MAX : SHRT_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)short_values[i]));
    actual.value = convert_uchar8((short8)short_values[i]);
    compare_uchar_elements("convert_uchar8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((short8)short_values[i]);
    compare_uchar_elements("convert_uchar8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UCHAR_MAX < SHRT_MAX) ? (short)UCHAR_MAX : SHRT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)short_values[i]));
    actual.value = convert_uchar16((short16)short_values[i]);
    compare_uchar_elements("convert_uchar16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((short16)short_values[i]);
    compare_uchar_elements("convert_uchar16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (SHRT_MIN > SHRT_MIN) ? (short)SHRT_MIN : SHRT_MIN;
    const short max_expected = (SHRT_MAX < SHRT_MAX) ? (short)SHRT_MAX : SHRT_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)short_values[i]));
    actual.value = convert_short((short)short_values[i]);
    compare_short_elements("convert_short((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((short)short_values[i]);
    compare_short_elements("convert_short_sat((short))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (SHRT_MIN > SHRT_MIN) ? (short)SHRT_MIN : SHRT_MIN;
    const short max_expected = (SHRT_MAX < SHRT_MAX) ? (short)SHRT_MAX : SHRT_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)short_values[i]));
    actual.value = convert_short2((short2)short_values[i]);
    compare_short_elements("convert_short2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((short2)short_values[i]);
    compare_short_elements("convert_short2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (SHRT_MIN > SHRT_MIN) ? (short)SHRT_MIN : SHRT_MIN;
    const short max_expected = (SHRT_MAX < SHRT_MAX) ? (short)SHRT_MAX : SHRT_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)short_values[i]));
    actual.value = convert_short4((short4)short_values[i]);
    compare_short_elements("convert_short4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((short4)short_values[i]);
    compare_short_elements("convert_short4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (SHRT_MIN > SHRT_MIN) ? (short)SHRT_MIN : SHRT_MIN;
    const short max_expected = (SHRT_MAX < SHRT_MAX) ? (short)SHRT_MAX : SHRT_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)short_values[i]));
    actual.value = convert_short8((short8)short_values[i]);
    compare_short_elements("convert_short8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((short8)short_values[i]);
    compare_short_elements("convert_short8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (SHRT_MIN > SHRT_MIN) ? (short)SHRT_MIN : SHRT_MIN;
    const short max_expected = (SHRT_MAX < SHRT_MAX) ? (short)SHRT_MAX : SHRT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)short_values[i]));
    actual.value = convert_short16((short16)short_values[i]);
    compare_short_elements("convert_short16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((short16)short_values[i]);
    compare_short_elements("convert_short16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (USHRT_MAX < SHRT_MAX) ? (short)USHRT_MAX : SHRT_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)short_values[i]));
    actual.value = convert_ushort((short)short_values[i]);
    compare_ushort_elements("convert_ushort((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((short)short_values[i]);
    compare_ushort_elements("convert_ushort_sat((short))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (USHRT_MAX < SHRT_MAX) ? (short)USHRT_MAX : SHRT_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)short_values[i]));
    actual.value = convert_ushort2((short2)short_values[i]);
    compare_ushort_elements("convert_ushort2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((short2)short_values[i]);
    compare_ushort_elements("convert_ushort2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (USHRT_MAX < SHRT_MAX) ? (short)USHRT_MAX : SHRT_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)short_values[i]));
    actual.value = convert_ushort4((short4)short_values[i]);
    compare_ushort_elements("convert_ushort4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((short4)short_values[i]);
    compare_ushort_elements("convert_ushort4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (USHRT_MAX < SHRT_MAX) ? (short)USHRT_MAX : SHRT_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)short_values[i]));
    actual.value = convert_ushort8((short8)short_values[i]);
    compare_ushort_elements("convert_ushort8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((short8)short_values[i]);
    compare_ushort_elements("convert_ushort8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (USHRT_MAX < SHRT_MAX) ? (short)USHRT_MAX : SHRT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)short_values[i]));
    actual.value = convert_ushort16((short16)short_values[i]);
    compare_ushort_elements("convert_ushort16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((short16)short_values[i]);
    compare_ushort_elements("convert_ushort16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (INT_MIN > SHRT_MIN) ? (short)INT_MIN : SHRT_MIN;
    const short max_expected = (INT_MAX < SHRT_MAX) ? (short)INT_MAX : SHRT_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)short_values[i]));
    actual.value = convert_int((short)short_values[i]);
    compare_int_elements("convert_int((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((short)short_values[i]);
    compare_int_elements("convert_int_sat((short))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (INT_MIN > SHRT_MIN) ? (short)INT_MIN : SHRT_MIN;
    const short max_expected = (INT_MAX < SHRT_MAX) ? (short)INT_MAX : SHRT_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)short_values[i]));
    actual.value = convert_int2((short2)short_values[i]);
    compare_int_elements("convert_int2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((short2)short_values[i]);
    compare_int_elements("convert_int2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (INT_MIN > SHRT_MIN) ? (short)INT_MIN : SHRT_MIN;
    const short max_expected = (INT_MAX < SHRT_MAX) ? (short)INT_MAX : SHRT_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)short_values[i]));
    actual.value = convert_int4((short4)short_values[i]);
    compare_int_elements("convert_int4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((short4)short_values[i]);
    compare_int_elements("convert_int4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (INT_MIN > SHRT_MIN) ? (short)INT_MIN : SHRT_MIN;
    const short max_expected = (INT_MAX < SHRT_MAX) ? (short)INT_MAX : SHRT_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)short_values[i]));
    actual.value = convert_int8((short8)short_values[i]);
    compare_int_elements("convert_int8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((short8)short_values[i]);
    compare_int_elements("convert_int8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (INT_MIN > SHRT_MIN) ? (short)INT_MIN : SHRT_MIN;
    const short max_expected = (INT_MAX < SHRT_MAX) ? (short)INT_MAX : SHRT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)short_values[i]));
    actual.value = convert_int16((short16)short_values[i]);
    compare_int_elements("convert_int16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((short16)short_values[i]);
    compare_int_elements("convert_int16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UINT_MAX < SHRT_MAX) ? (short)UINT_MAX : SHRT_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)short_values[i]));
    actual.value = convert_uint((short)short_values[i]);
    compare_uint_elements("convert_uint((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((short)short_values[i]);
    compare_uint_elements("convert_uint_sat((short))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UINT_MAX < SHRT_MAX) ? (short)UINT_MAX : SHRT_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)short_values[i]));
    actual.value = convert_uint2((short2)short_values[i]);
    compare_uint_elements("convert_uint2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((short2)short_values[i]);
    compare_uint_elements("convert_uint2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UINT_MAX < SHRT_MAX) ? (short)UINT_MAX : SHRT_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)short_values[i]));
    actual.value = convert_uint4((short4)short_values[i]);
    compare_uint_elements("convert_uint4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((short4)short_values[i]);
    compare_uint_elements("convert_uint4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UINT_MAX < SHRT_MAX) ? (short)UINT_MAX : SHRT_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)short_values[i]));
    actual.value = convert_uint8((short8)short_values[i]);
    compare_uint_elements("convert_uint8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((short8)short_values[i]);
    compare_uint_elements("convert_uint8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (UINT_MAX < SHRT_MAX) ? (short)UINT_MAX : SHRT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)short_values[i]));
    actual.value = convert_uint16((short16)short_values[i]);
    compare_uint_elements("convert_uint16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((short16)short_values[i]);
    compare_uint_elements("convert_uint16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (LONG_MIN > SHRT_MIN) ? (short)LONG_MIN : SHRT_MIN;
    const short max_expected = (LONG_MAX < SHRT_MAX) ? (short)LONG_MAX : SHRT_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)short_values[i]));
    actual.value = convert_long((short)short_values[i]);
    compare_long_elements("convert_long((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((short)short_values[i]);
    compare_long_elements("convert_long_sat((short))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (LONG_MIN > SHRT_MIN) ? (short)LONG_MIN : SHRT_MIN;
    const short max_expected = (LONG_MAX < SHRT_MAX) ? (short)LONG_MAX : SHRT_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)short_values[i]));
    actual.value = convert_long2((short2)short_values[i]);
    compare_long_elements("convert_long2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((short2)short_values[i]);
    compare_long_elements("convert_long2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (LONG_MIN > SHRT_MIN) ? (short)LONG_MIN : SHRT_MIN;
    const short max_expected = (LONG_MAX < SHRT_MAX) ? (short)LONG_MAX : SHRT_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)short_values[i]));
    actual.value = convert_long4((short4)short_values[i]);
    compare_long_elements("convert_long4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((short4)short_values[i]);
    compare_long_elements("convert_long4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (LONG_MIN > SHRT_MIN) ? (short)LONG_MIN : SHRT_MIN;
    const short max_expected = (LONG_MAX < SHRT_MAX) ? (short)LONG_MAX : SHRT_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)short_values[i]));
    actual.value = convert_long8((short8)short_values[i]);
    compare_long_elements("convert_long8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((short8)short_values[i]);
    compare_long_elements("convert_long8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (LONG_MIN > SHRT_MIN) ? (short)LONG_MIN : SHRT_MIN;
    const short max_expected = (LONG_MAX < SHRT_MAX) ? (short)LONG_MAX : SHRT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)short_values[i]));
    actual.value = convert_long16((short16)short_values[i]);
    compare_long_elements("convert_long16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((short16)short_values[i]);
    compare_long_elements("convert_long16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (ULONG_MAX < SHRT_MAX) ? (short)ULONG_MAX : SHRT_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)short_values[i]));
    actual.value = convert_ulong((short)short_values[i]);
    compare_ulong_elements("convert_ulong((short))", i, expected.raw, actual.raw, 1);
    if (short_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((short)short_values[i]);
    compare_ulong_elements("convert_ulong_sat((short))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (ULONG_MAX < SHRT_MAX) ? (short)ULONG_MAX : SHRT_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)short_values[i]));
    actual.value = convert_ulong2((short2)short_values[i]);
    compare_ulong_elements("convert_ulong2((short2))", i, expected.raw, actual.raw, 2);
    if (short_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((short2)short_values[i]);
    compare_ulong_elements("convert_ulong2_sat((short2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (ULONG_MAX < SHRT_MAX) ? (short)ULONG_MAX : SHRT_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)short_values[i]));
    actual.value = convert_ulong4((short4)short_values[i]);
    compare_ulong_elements("convert_ulong4((short4))", i, expected.raw, actual.raw, 4);
    if (short_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((short4)short_values[i]);
    compare_ulong_elements("convert_ulong4_sat((short4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (ULONG_MAX < SHRT_MAX) ? (short)ULONG_MAX : SHRT_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)short_values[i]));
    actual.value = convert_ulong8((short8)short_values[i]);
    compare_ulong_elements("convert_ulong8((short8))", i, expected.raw, actual.raw, 8);
    if (short_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((short8)short_values[i]);
    compare_ulong_elements("convert_ulong8_sat((short8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (ULONG_MAX < SHRT_MAX) ? (short)ULONG_MAX : SHRT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)short_values[i]));
    actual.value = convert_ulong16((short16)short_values[i]);
    compare_ulong_elements("convert_ulong16((short16))", i, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((short16)short_values[i]);
    compare_ulong_elements("convert_ulong16_sat((short16))", i, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (CHAR_MIN > 0) ? (ushort)CHAR_MIN : 0;
    const ushort max_expected = (CHAR_MAX < USHRT_MAX) ? (ushort)CHAR_MAX : USHRT_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)ushort_values[i]));
    actual.value = convert_char((ushort)ushort_values[i]);
    compare_char_elements("convert_char((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((ushort)ushort_values[i]);
    compare_char_elements("convert_char_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (CHAR_MIN > 0) ? (ushort)CHAR_MIN : 0;
    const ushort max_expected = (CHAR_MAX < USHRT_MAX) ? (ushort)CHAR_MAX : USHRT_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)ushort_values[i]));
    actual.value = convert_char2((ushort2)ushort_values[i]);
    compare_char_elements("convert_char2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((ushort2)ushort_values[i]);
    compare_char_elements("convert_char2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (CHAR_MIN > 0) ? (ushort)CHAR_MIN : 0;
    const ushort max_expected = (CHAR_MAX < USHRT_MAX) ? (ushort)CHAR_MAX : USHRT_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)ushort_values[i]));
    actual.value = convert_char4((ushort4)ushort_values[i]);
    compare_char_elements("convert_char4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((ushort4)ushort_values[i]);
    compare_char_elements("convert_char4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (CHAR_MIN > 0) ? (ushort)CHAR_MIN : 0;
    const ushort max_expected = (CHAR_MAX < USHRT_MAX) ? (ushort)CHAR_MAX : USHRT_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)ushort_values[i]));
    actual.value = convert_char8((ushort8)ushort_values[i]);
    compare_char_elements("convert_char8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((ushort8)ushort_values[i]);
    compare_char_elements("convert_char8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (CHAR_MIN > 0) ? (ushort)CHAR_MIN : 0;
    const ushort max_expected = (CHAR_MAX < USHRT_MAX) ? (ushort)CHAR_MAX : USHRT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)ushort_values[i]));
    actual.value = convert_char16((ushort16)ushort_values[i]);
    compare_char_elements("convert_char16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((ushort16)ushort_values[i]);
    compare_char_elements("convert_char16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UCHAR_MAX < USHRT_MAX) ? (ushort)UCHAR_MAX : USHRT_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)ushort_values[i]));
    actual.value = convert_uchar((ushort)ushort_values[i]);
    compare_uchar_elements("convert_uchar((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((ushort)ushort_values[i]);
    compare_uchar_elements("convert_uchar_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UCHAR_MAX < USHRT_MAX) ? (ushort)UCHAR_MAX : USHRT_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)ushort_values[i]));
    actual.value = convert_uchar2((ushort2)ushort_values[i]);
    compare_uchar_elements("convert_uchar2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((ushort2)ushort_values[i]);
    compare_uchar_elements("convert_uchar2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UCHAR_MAX < USHRT_MAX) ? (ushort)UCHAR_MAX : USHRT_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)ushort_values[i]));
    actual.value = convert_uchar4((ushort4)ushort_values[i]);
    compare_uchar_elements("convert_uchar4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((ushort4)ushort_values[i]);
    compare_uchar_elements("convert_uchar4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UCHAR_MAX < USHRT_MAX) ? (ushort)UCHAR_MAX : USHRT_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)ushort_values[i]));
    actual.value = convert_uchar8((ushort8)ushort_values[i]);
    compare_uchar_elements("convert_uchar8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((ushort8)ushort_values[i]);
    compare_uchar_elements("convert_uchar8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UCHAR_MAX < USHRT_MAX) ? (ushort)UCHAR_MAX : USHRT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)ushort_values[i]));
    actual.value = convert_uchar16((ushort16)ushort_values[i]);
    compare_uchar_elements("convert_uchar16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((ushort16)ushort_values[i]);
    compare_uchar_elements("convert_uchar16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (SHRT_MIN > 0) ? (ushort)SHRT_MIN : 0;
    const ushort max_expected = (SHRT_MAX < USHRT_MAX) ? (ushort)SHRT_MAX : USHRT_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)ushort_values[i]));
    actual.value = convert_short((ushort)ushort_values[i]);
    compare_short_elements("convert_short((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((ushort)ushort_values[i]);
    compare_short_elements("convert_short_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (SHRT_MIN > 0) ? (ushort)SHRT_MIN : 0;
    const ushort max_expected = (SHRT_MAX < USHRT_MAX) ? (ushort)SHRT_MAX : USHRT_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)ushort_values[i]));
    actual.value = convert_short2((ushort2)ushort_values[i]);
    compare_short_elements("convert_short2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((ushort2)ushort_values[i]);
    compare_short_elements("convert_short2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (SHRT_MIN > 0) ? (ushort)SHRT_MIN : 0;
    const ushort max_expected = (SHRT_MAX < USHRT_MAX) ? (ushort)SHRT_MAX : USHRT_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)ushort_values[i]));
    actual.value = convert_short4((ushort4)ushort_values[i]);
    compare_short_elements("convert_short4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((ushort4)ushort_values[i]);
    compare_short_elements("convert_short4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (SHRT_MIN > 0) ? (ushort)SHRT_MIN : 0;
    const ushort max_expected = (SHRT_MAX < USHRT_MAX) ? (ushort)SHRT_MAX : USHRT_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)ushort_values[i]));
    actual.value = convert_short8((ushort8)ushort_values[i]);
    compare_short_elements("convert_short8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((ushort8)ushort_values[i]);
    compare_short_elements("convert_short8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (SHRT_MIN > 0) ? (ushort)SHRT_MIN : 0;
    const ushort max_expected = (SHRT_MAX < USHRT_MAX) ? (ushort)SHRT_MAX : USHRT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)ushort_values[i]));
    actual.value = convert_short16((ushort16)ushort_values[i]);
    compare_short_elements("convert_short16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((ushort16)ushort_values[i]);
    compare_short_elements("convert_short16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (USHRT_MAX < USHRT_MAX) ? (ushort)USHRT_MAX : USHRT_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)ushort_values[i]));
    actual.value = convert_ushort((ushort)ushort_values[i]);
    compare_ushort_elements("convert_ushort((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((ushort)ushort_values[i]);
    compare_ushort_elements("convert_ushort_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (USHRT_MAX < USHRT_MAX) ? (ushort)USHRT_MAX : USHRT_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)ushort_values[i]));
    actual.value = convert_ushort2((ushort2)ushort_values[i]);
    compare_ushort_elements("convert_ushort2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((ushort2)ushort_values[i]);
    compare_ushort_elements("convert_ushort2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (USHRT_MAX < USHRT_MAX) ? (ushort)USHRT_MAX : USHRT_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)ushort_values[i]));
    actual.value = convert_ushort4((ushort4)ushort_values[i]);
    compare_ushort_elements("convert_ushort4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((ushort4)ushort_values[i]);
    compare_ushort_elements("convert_ushort4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (USHRT_MAX < USHRT_MAX) ? (ushort)USHRT_MAX : USHRT_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)ushort_values[i]));
    actual.value = convert_ushort8((ushort8)ushort_values[i]);
    compare_ushort_elements("convert_ushort8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((ushort8)ushort_values[i]);
    compare_ushort_elements("convert_ushort8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (USHRT_MAX < USHRT_MAX) ? (ushort)USHRT_MAX : USHRT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)ushort_values[i]));
    actual.value = convert_ushort16((ushort16)ushort_values[i]);
    compare_ushort_elements("convert_ushort16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((ushort16)ushort_values[i]);
    compare_ushort_elements("convert_ushort16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (INT_MIN > 0) ? (ushort)INT_MIN : 0;
    const ushort max_expected = (INT_MAX < USHRT_MAX) ? (ushort)INT_MAX : USHRT_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)ushort_values[i]));
    actual.value = convert_int((ushort)ushort_values[i]);
    compare_int_elements("convert_int((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((ushort)ushort_values[i]);
    compare_int_elements("convert_int_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (INT_MIN > 0) ? (ushort)INT_MIN : 0;
    const ushort max_expected = (INT_MAX < USHRT_MAX) ? (ushort)INT_MAX : USHRT_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)ushort_values[i]));
    actual.value = convert_int2((ushort2)ushort_values[i]);
    compare_int_elements("convert_int2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((ushort2)ushort_values[i]);
    compare_int_elements("convert_int2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (INT_MIN > 0) ? (ushort)INT_MIN : 0;
    const ushort max_expected = (INT_MAX < USHRT_MAX) ? (ushort)INT_MAX : USHRT_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)ushort_values[i]));
    actual.value = convert_int4((ushort4)ushort_values[i]);
    compare_int_elements("convert_int4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((ushort4)ushort_values[i]);
    compare_int_elements("convert_int4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (INT_MIN > 0) ? (ushort)INT_MIN : 0;
    const ushort max_expected = (INT_MAX < USHRT_MAX) ? (ushort)INT_MAX : USHRT_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)ushort_values[i]));
    actual.value = convert_int8((ushort8)ushort_values[i]);
    compare_int_elements("convert_int8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((ushort8)ushort_values[i]);
    compare_int_elements("convert_int8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (INT_MIN > 0) ? (ushort)INT_MIN : 0;
    const ushort max_expected = (INT_MAX < USHRT_MAX) ? (ushort)INT_MAX : USHRT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)ushort_values[i]));
    actual.value = convert_int16((ushort16)ushort_values[i]);
    compare_int_elements("convert_int16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((ushort16)ushort_values[i]);
    compare_int_elements("convert_int16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UINT_MAX < USHRT_MAX) ? (ushort)UINT_MAX : USHRT_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)ushort_values[i]));
    actual.value = convert_uint((ushort)ushort_values[i]);
    compare_uint_elements("convert_uint((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((ushort)ushort_values[i]);
    compare_uint_elements("convert_uint_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UINT_MAX < USHRT_MAX) ? (ushort)UINT_MAX : USHRT_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)ushort_values[i]));
    actual.value = convert_uint2((ushort2)ushort_values[i]);
    compare_uint_elements("convert_uint2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((ushort2)ushort_values[i]);
    compare_uint_elements("convert_uint2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UINT_MAX < USHRT_MAX) ? (ushort)UINT_MAX : USHRT_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)ushort_values[i]));
    actual.value = convert_uint4((ushort4)ushort_values[i]);
    compare_uint_elements("convert_uint4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((ushort4)ushort_values[i]);
    compare_uint_elements("convert_uint4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UINT_MAX < USHRT_MAX) ? (ushort)UINT_MAX : USHRT_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)ushort_values[i]));
    actual.value = convert_uint8((ushort8)ushort_values[i]);
    compare_uint_elements("convert_uint8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((ushort8)ushort_values[i]);
    compare_uint_elements("convert_uint8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (UINT_MAX < USHRT_MAX) ? (ushort)UINT_MAX : USHRT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)ushort_values[i]));
    actual.value = convert_uint16((ushort16)ushort_values[i]);
    compare_uint_elements("convert_uint16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((ushort16)ushort_values[i]);
    compare_uint_elements("convert_uint16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (LONG_MIN > 0) ? (ushort)LONG_MIN : 0;
    const ushort max_expected = (LONG_MAX < USHRT_MAX) ? (ushort)LONG_MAX : USHRT_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)ushort_values[i]));
    actual.value = convert_long((ushort)ushort_values[i]);
    compare_long_elements("convert_long((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((ushort)ushort_values[i]);
    compare_long_elements("convert_long_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (LONG_MIN > 0) ? (ushort)LONG_MIN : 0;
    const ushort max_expected = (LONG_MAX < USHRT_MAX) ? (ushort)LONG_MAX : USHRT_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)ushort_values[i]));
    actual.value = convert_long2((ushort2)ushort_values[i]);
    compare_long_elements("convert_long2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((ushort2)ushort_values[i]);
    compare_long_elements("convert_long2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (LONG_MIN > 0) ? (ushort)LONG_MIN : 0;
    const ushort max_expected = (LONG_MAX < USHRT_MAX) ? (ushort)LONG_MAX : USHRT_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)ushort_values[i]));
    actual.value = convert_long4((ushort4)ushort_values[i]);
    compare_long_elements("convert_long4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((ushort4)ushort_values[i]);
    compare_long_elements("convert_long4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (LONG_MIN > 0) ? (ushort)LONG_MIN : 0;
    const ushort max_expected = (LONG_MAX < USHRT_MAX) ? (ushort)LONG_MAX : USHRT_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)ushort_values[i]));
    actual.value = convert_long8((ushort8)ushort_values[i]);
    compare_long_elements("convert_long8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((ushort8)ushort_values[i]);
    compare_long_elements("convert_long8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (LONG_MIN > 0) ? (ushort)LONG_MIN : 0;
    const ushort max_expected = (LONG_MAX < USHRT_MAX) ? (ushort)LONG_MAX : USHRT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)ushort_values[i]));
    actual.value = convert_long16((ushort16)ushort_values[i]);
    compare_long_elements("convert_long16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((ushort16)ushort_values[i]);
    compare_long_elements("convert_long16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ULONG_MAX < USHRT_MAX) ? (ushort)ULONG_MAX : USHRT_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)ushort_values[i]));
    actual.value = convert_ulong((ushort)ushort_values[i]);
    compare_ulong_elements("convert_ulong((ushort))", i, expected.raw, actual.raw, 1);
    if (ushort_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((ushort)ushort_values[i]);
    compare_ulong_elements("convert_ulong_sat((ushort))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ULONG_MAX < USHRT_MAX) ? (ushort)ULONG_MAX : USHRT_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)ushort_values[i]));
    actual.value = convert_ulong2((ushort2)ushort_values[i]);
    compare_ulong_elements("convert_ulong2((ushort2))", i, expected.raw, actual.raw, 2);
    if (ushort_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((ushort2)ushort_values[i]);
    compare_ulong_elements("convert_ulong2_sat((ushort2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ULONG_MAX < USHRT_MAX) ? (ushort)ULONG_MAX : USHRT_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)ushort_values[i]));
    actual.value = convert_ulong4((ushort4)ushort_values[i]);
    compare_ulong_elements("convert_ulong4((ushort4))", i, expected.raw, actual.raw, 4);
    if (ushort_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((ushort4)ushort_values[i]);
    compare_ulong_elements("convert_ulong4_sat((ushort4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ULONG_MAX < USHRT_MAX) ? (ushort)ULONG_MAX : USHRT_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)ushort_values[i]));
    actual.value = convert_ulong8((ushort8)ushort_values[i]);
    compare_ulong_elements("convert_ulong8((ushort8))", i, expected.raw, actual.raw, 8);
    if (ushort_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((ushort8)ushort_values[i]);
    compare_ulong_elements("convert_ulong8_sat((ushort8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ULONG_MAX < USHRT_MAX) ? (ushort)ULONG_MAX : USHRT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)ushort_values[i]));
    actual.value = convert_ulong16((ushort16)ushort_values[i]);
    compare_ulong_elements("convert_ulong16((ushort16))", i, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((ushort16)ushort_values[i]);
    compare_ulong_elements("convert_ulong16_sat((ushort16))", i, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (CHAR_MIN > INT_MIN) ? (int)CHAR_MIN : INT_MIN;
    const int max_expected = (CHAR_MAX < INT_MAX) ? (int)CHAR_MAX : INT_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)int_values[i]));
    actual.value = convert_char((int)int_values[i]);
    compare_char_elements("convert_char((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((int)int_values[i]);
    compare_char_elements("convert_char_sat((int))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (CHAR_MIN > INT_MIN) ? (int)CHAR_MIN : INT_MIN;
    const int max_expected = (CHAR_MAX < INT_MAX) ? (int)CHAR_MAX : INT_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)int_values[i]));
    actual.value = convert_char2((int2)int_values[i]);
    compare_char_elements("convert_char2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((int2)int_values[i]);
    compare_char_elements("convert_char2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (CHAR_MIN > INT_MIN) ? (int)CHAR_MIN : INT_MIN;
    const int max_expected = (CHAR_MAX < INT_MAX) ? (int)CHAR_MAX : INT_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)int_values[i]));
    actual.value = convert_char4((int4)int_values[i]);
    compare_char_elements("convert_char4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((int4)int_values[i]);
    compare_char_elements("convert_char4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (CHAR_MIN > INT_MIN) ? (int)CHAR_MIN : INT_MIN;
    const int max_expected = (CHAR_MAX < INT_MAX) ? (int)CHAR_MAX : INT_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)int_values[i]));
    actual.value = convert_char8((int8)int_values[i]);
    compare_char_elements("convert_char8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((int8)int_values[i]);
    compare_char_elements("convert_char8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (CHAR_MIN > INT_MIN) ? (int)CHAR_MIN : INT_MIN;
    const int max_expected = (CHAR_MAX < INT_MAX) ? (int)CHAR_MAX : INT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)int_values[i]));
    actual.value = convert_char16((int16)int_values[i]);
    compare_char_elements("convert_char16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((int16)int_values[i]);
    compare_char_elements("convert_char16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UCHAR_MAX < INT_MAX) ? (int)UCHAR_MAX : INT_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)int_values[i]));
    actual.value = convert_uchar((int)int_values[i]);
    compare_uchar_elements("convert_uchar((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((int)int_values[i]);
    compare_uchar_elements("convert_uchar_sat((int))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UCHAR_MAX < INT_MAX) ? (int)UCHAR_MAX : INT_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)int_values[i]));
    actual.value = convert_uchar2((int2)int_values[i]);
    compare_uchar_elements("convert_uchar2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((int2)int_values[i]);
    compare_uchar_elements("convert_uchar2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UCHAR_MAX < INT_MAX) ? (int)UCHAR_MAX : INT_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)int_values[i]));
    actual.value = convert_uchar4((int4)int_values[i]);
    compare_uchar_elements("convert_uchar4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((int4)int_values[i]);
    compare_uchar_elements("convert_uchar4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UCHAR_MAX < INT_MAX) ? (int)UCHAR_MAX : INT_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)int_values[i]));
    actual.value = convert_uchar8((int8)int_values[i]);
    compare_uchar_elements("convert_uchar8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((int8)int_values[i]);
    compare_uchar_elements("convert_uchar8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UCHAR_MAX < INT_MAX) ? (int)UCHAR_MAX : INT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)int_values[i]));
    actual.value = convert_uchar16((int16)int_values[i]);
    compare_uchar_elements("convert_uchar16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((int16)int_values[i]);
    compare_uchar_elements("convert_uchar16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (SHRT_MIN > INT_MIN) ? (int)SHRT_MIN : INT_MIN;
    const int max_expected = (SHRT_MAX < INT_MAX) ? (int)SHRT_MAX : INT_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)int_values[i]));
    actual.value = convert_short((int)int_values[i]);
    compare_short_elements("convert_short((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((int)int_values[i]);
    compare_short_elements("convert_short_sat((int))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (SHRT_MIN > INT_MIN) ? (int)SHRT_MIN : INT_MIN;
    const int max_expected = (SHRT_MAX < INT_MAX) ? (int)SHRT_MAX : INT_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)int_values[i]));
    actual.value = convert_short2((int2)int_values[i]);
    compare_short_elements("convert_short2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((int2)int_values[i]);
    compare_short_elements("convert_short2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (SHRT_MIN > INT_MIN) ? (int)SHRT_MIN : INT_MIN;
    const int max_expected = (SHRT_MAX < INT_MAX) ? (int)SHRT_MAX : INT_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)int_values[i]));
    actual.value = convert_short4((int4)int_values[i]);
    compare_short_elements("convert_short4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((int4)int_values[i]);
    compare_short_elements("convert_short4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (SHRT_MIN > INT_MIN) ? (int)SHRT_MIN : INT_MIN;
    const int max_expected = (SHRT_MAX < INT_MAX) ? (int)SHRT_MAX : INT_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)int_values[i]));
    actual.value = convert_short8((int8)int_values[i]);
    compare_short_elements("convert_short8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((int8)int_values[i]);
    compare_short_elements("convert_short8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (SHRT_MIN > INT_MIN) ? (int)SHRT_MIN : INT_MIN;
    const int max_expected = (SHRT_MAX < INT_MAX) ? (int)SHRT_MAX : INT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)int_values[i]));
    actual.value = convert_short16((int16)int_values[i]);
    compare_short_elements("convert_short16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((int16)int_values[i]);
    compare_short_elements("convert_short16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (USHRT_MAX < INT_MAX) ? (int)USHRT_MAX : INT_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)int_values[i]));
    actual.value = convert_ushort((int)int_values[i]);
    compare_ushort_elements("convert_ushort((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((int)int_values[i]);
    compare_ushort_elements("convert_ushort_sat((int))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (USHRT_MAX < INT_MAX) ? (int)USHRT_MAX : INT_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)int_values[i]));
    actual.value = convert_ushort2((int2)int_values[i]);
    compare_ushort_elements("convert_ushort2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((int2)int_values[i]);
    compare_ushort_elements("convert_ushort2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (USHRT_MAX < INT_MAX) ? (int)USHRT_MAX : INT_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)int_values[i]));
    actual.value = convert_ushort4((int4)int_values[i]);
    compare_ushort_elements("convert_ushort4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((int4)int_values[i]);
    compare_ushort_elements("convert_ushort4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (USHRT_MAX < INT_MAX) ? (int)USHRT_MAX : INT_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)int_values[i]));
    actual.value = convert_ushort8((int8)int_values[i]);
    compare_ushort_elements("convert_ushort8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((int8)int_values[i]);
    compare_ushort_elements("convert_ushort8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (USHRT_MAX < INT_MAX) ? (int)USHRT_MAX : INT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)int_values[i]));
    actual.value = convert_ushort16((int16)int_values[i]);
    compare_ushort_elements("convert_ushort16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((int16)int_values[i]);
    compare_ushort_elements("convert_ushort16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (INT_MIN > INT_MIN) ? (int)INT_MIN : INT_MIN;
    const int max_expected = (INT_MAX < INT_MAX) ? (int)INT_MAX : INT_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)int_values[i]));
    actual.value = convert_int((int)int_values[i]);
    compare_int_elements("convert_int((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((int)int_values[i]);
    compare_int_elements("convert_int_sat((int))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (INT_MIN > INT_MIN) ? (int)INT_MIN : INT_MIN;
    const int max_expected = (INT_MAX < INT_MAX) ? (int)INT_MAX : INT_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)int_values[i]));
    actual.value = convert_int2((int2)int_values[i]);
    compare_int_elements("convert_int2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((int2)int_values[i]);
    compare_int_elements("convert_int2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (INT_MIN > INT_MIN) ? (int)INT_MIN : INT_MIN;
    const int max_expected = (INT_MAX < INT_MAX) ? (int)INT_MAX : INT_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)int_values[i]));
    actual.value = convert_int4((int4)int_values[i]);
    compare_int_elements("convert_int4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((int4)int_values[i]);
    compare_int_elements("convert_int4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (INT_MIN > INT_MIN) ? (int)INT_MIN : INT_MIN;
    const int max_expected = (INT_MAX < INT_MAX) ? (int)INT_MAX : INT_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)int_values[i]));
    actual.value = convert_int8((int8)int_values[i]);
    compare_int_elements("convert_int8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((int8)int_values[i]);
    compare_int_elements("convert_int8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (INT_MIN > INT_MIN) ? (int)INT_MIN : INT_MIN;
    const int max_expected = (INT_MAX < INT_MAX) ? (int)INT_MAX : INT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)int_values[i]));
    actual.value = convert_int16((int16)int_values[i]);
    compare_int_elements("convert_int16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((int16)int_values[i]);
    compare_int_elements("convert_int16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UINT_MAX < INT_MAX) ? (int)UINT_MAX : INT_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)int_values[i]));
    actual.value = convert_uint((int)int_values[i]);
    compare_uint_elements("convert_uint((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((int)int_values[i]);
    compare_uint_elements("convert_uint_sat((int))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UINT_MAX < INT_MAX) ? (int)UINT_MAX : INT_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)int_values[i]));
    actual.value = convert_uint2((int2)int_values[i]);
    compare_uint_elements("convert_uint2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((int2)int_values[i]);
    compare_uint_elements("convert_uint2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UINT_MAX < INT_MAX) ? (int)UINT_MAX : INT_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)int_values[i]));
    actual.value = convert_uint4((int4)int_values[i]);
    compare_uint_elements("convert_uint4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((int4)int_values[i]);
    compare_uint_elements("convert_uint4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UINT_MAX < INT_MAX) ? (int)UINT_MAX : INT_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)int_values[i]));
    actual.value = convert_uint8((int8)int_values[i]);
    compare_uint_elements("convert_uint8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((int8)int_values[i]);
    compare_uint_elements("convert_uint8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (UINT_MAX < INT_MAX) ? (int)UINT_MAX : INT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)int_values[i]));
    actual.value = convert_uint16((int16)int_values[i]);
    compare_uint_elements("convert_uint16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((int16)int_values[i]);
    compare_uint_elements("convert_uint16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (LONG_MIN > INT_MIN) ? (int)LONG_MIN : INT_MIN;
    const int max_expected = (LONG_MAX < INT_MAX) ? (int)LONG_MAX : INT_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)int_values[i]));
    actual.value = convert_long((int)int_values[i]);
    compare_long_elements("convert_long((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((int)int_values[i]);
    compare_long_elements("convert_long_sat((int))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (LONG_MIN > INT_MIN) ? (int)LONG_MIN : INT_MIN;
    const int max_expected = (LONG_MAX < INT_MAX) ? (int)LONG_MAX : INT_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)int_values[i]));
    actual.value = convert_long2((int2)int_values[i]);
    compare_long_elements("convert_long2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((int2)int_values[i]);
    compare_long_elements("convert_long2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (LONG_MIN > INT_MIN) ? (int)LONG_MIN : INT_MIN;
    const int max_expected = (LONG_MAX < INT_MAX) ? (int)LONG_MAX : INT_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)int_values[i]));
    actual.value = convert_long4((int4)int_values[i]);
    compare_long_elements("convert_long4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((int4)int_values[i]);
    compare_long_elements("convert_long4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (LONG_MIN > INT_MIN) ? (int)LONG_MIN : INT_MIN;
    const int max_expected = (LONG_MAX < INT_MAX) ? (int)LONG_MAX : INT_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)int_values[i]));
    actual.value = convert_long8((int8)int_values[i]);
    compare_long_elements("convert_long8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((int8)int_values[i]);
    compare_long_elements("convert_long8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (LONG_MIN > INT_MIN) ? (int)LONG_MIN : INT_MIN;
    const int max_expected = (LONG_MAX < INT_MAX) ? (int)LONG_MAX : INT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)int_values[i]));
    actual.value = convert_long16((int16)int_values[i]);
    compare_long_elements("convert_long16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((int16)int_values[i]);
    compare_long_elements("convert_long16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (ULONG_MAX < INT_MAX) ? (int)ULONG_MAX : INT_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)int_values[i]));
    actual.value = convert_ulong((int)int_values[i]);
    compare_ulong_elements("convert_ulong((int))", i, expected.raw, actual.raw, 1);
    if (int_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((int)int_values[i]);
    compare_ulong_elements("convert_ulong_sat((int))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (ULONG_MAX < INT_MAX) ? (int)ULONG_MAX : INT_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)int_values[i]));
    actual.value = convert_ulong2((int2)int_values[i]);
    compare_ulong_elements("convert_ulong2((int2))", i, expected.raw, actual.raw, 2);
    if (int_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((int2)int_values[i]);
    compare_ulong_elements("convert_ulong2_sat((int2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (ULONG_MAX < INT_MAX) ? (int)ULONG_MAX : INT_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)int_values[i]));
    actual.value = convert_ulong4((int4)int_values[i]);
    compare_ulong_elements("convert_ulong4((int4))", i, expected.raw, actual.raw, 4);
    if (int_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((int4)int_values[i]);
    compare_ulong_elements("convert_ulong4_sat((int4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (ULONG_MAX < INT_MAX) ? (int)ULONG_MAX : INT_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)int_values[i]));
    actual.value = convert_ulong8((int8)int_values[i]);
    compare_ulong_elements("convert_ulong8((int8))", i, expected.raw, actual.raw, 8);
    if (int_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((int8)int_values[i]);
    compare_ulong_elements("convert_ulong8_sat((int8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (ULONG_MAX < INT_MAX) ? (int)ULONG_MAX : INT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)int_values[i]));
    actual.value = convert_ulong16((int16)int_values[i]);
    compare_ulong_elements("convert_ulong16((int16))", i, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((int16)int_values[i]);
    compare_ulong_elements("convert_ulong16_sat((int16))", i, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (CHAR_MIN > 0) ? (uint)CHAR_MIN : 0;
    const uint max_expected = (CHAR_MAX < UINT_MAX) ? (uint)CHAR_MAX : UINT_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)uint_values[i]));
    actual.value = convert_char((uint)uint_values[i]);
    compare_char_elements("convert_char((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((uint)uint_values[i]);
    compare_char_elements("convert_char_sat((uint))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (CHAR_MIN > 0) ? (uint)CHAR_MIN : 0;
    const uint max_expected = (CHAR_MAX < UINT_MAX) ? (uint)CHAR_MAX : UINT_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)uint_values[i]));
    actual.value = convert_char2((uint2)uint_values[i]);
    compare_char_elements("convert_char2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((uint2)uint_values[i]);
    compare_char_elements("convert_char2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (CHAR_MIN > 0) ? (uint)CHAR_MIN : 0;
    const uint max_expected = (CHAR_MAX < UINT_MAX) ? (uint)CHAR_MAX : UINT_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)uint_values[i]));
    actual.value = convert_char4((uint4)uint_values[i]);
    compare_char_elements("convert_char4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((uint4)uint_values[i]);
    compare_char_elements("convert_char4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (CHAR_MIN > 0) ? (uint)CHAR_MIN : 0;
    const uint max_expected = (CHAR_MAX < UINT_MAX) ? (uint)CHAR_MAX : UINT_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)uint_values[i]));
    actual.value = convert_char8((uint8)uint_values[i]);
    compare_char_elements("convert_char8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((uint8)uint_values[i]);
    compare_char_elements("convert_char8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (CHAR_MIN > 0) ? (uint)CHAR_MIN : 0;
    const uint max_expected = (CHAR_MAX < UINT_MAX) ? (uint)CHAR_MAX : UINT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)uint_values[i]));
    actual.value = convert_char16((uint16)uint_values[i]);
    compare_char_elements("convert_char16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((uint16)uint_values[i]);
    compare_char_elements("convert_char16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UCHAR_MAX < UINT_MAX) ? (uint)UCHAR_MAX : UINT_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)uint_values[i]));
    actual.value = convert_uchar((uint)uint_values[i]);
    compare_uchar_elements("convert_uchar((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((uint)uint_values[i]);
    compare_uchar_elements("convert_uchar_sat((uint))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UCHAR_MAX < UINT_MAX) ? (uint)UCHAR_MAX : UINT_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)uint_values[i]));
    actual.value = convert_uchar2((uint2)uint_values[i]);
    compare_uchar_elements("convert_uchar2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((uint2)uint_values[i]);
    compare_uchar_elements("convert_uchar2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UCHAR_MAX < UINT_MAX) ? (uint)UCHAR_MAX : UINT_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)uint_values[i]));
    actual.value = convert_uchar4((uint4)uint_values[i]);
    compare_uchar_elements("convert_uchar4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((uint4)uint_values[i]);
    compare_uchar_elements("convert_uchar4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UCHAR_MAX < UINT_MAX) ? (uint)UCHAR_MAX : UINT_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)uint_values[i]));
    actual.value = convert_uchar8((uint8)uint_values[i]);
    compare_uchar_elements("convert_uchar8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((uint8)uint_values[i]);
    compare_uchar_elements("convert_uchar8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UCHAR_MAX < UINT_MAX) ? (uint)UCHAR_MAX : UINT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)uint_values[i]));
    actual.value = convert_uchar16((uint16)uint_values[i]);
    compare_uchar_elements("convert_uchar16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((uint16)uint_values[i]);
    compare_uchar_elements("convert_uchar16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (SHRT_MIN > 0) ? (uint)SHRT_MIN : 0;
    const uint max_expected = (SHRT_MAX < UINT_MAX) ? (uint)SHRT_MAX : UINT_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)uint_values[i]));
    actual.value = convert_short((uint)uint_values[i]);
    compare_short_elements("convert_short((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((uint)uint_values[i]);
    compare_short_elements("convert_short_sat((uint))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (SHRT_MIN > 0) ? (uint)SHRT_MIN : 0;
    const uint max_expected = (SHRT_MAX < UINT_MAX) ? (uint)SHRT_MAX : UINT_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)uint_values[i]));
    actual.value = convert_short2((uint2)uint_values[i]);
    compare_short_elements("convert_short2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((uint2)uint_values[i]);
    compare_short_elements("convert_short2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (SHRT_MIN > 0) ? (uint)SHRT_MIN : 0;
    const uint max_expected = (SHRT_MAX < UINT_MAX) ? (uint)SHRT_MAX : UINT_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)uint_values[i]));
    actual.value = convert_short4((uint4)uint_values[i]);
    compare_short_elements("convert_short4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((uint4)uint_values[i]);
    compare_short_elements("convert_short4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (SHRT_MIN > 0) ? (uint)SHRT_MIN : 0;
    const uint max_expected = (SHRT_MAX < UINT_MAX) ? (uint)SHRT_MAX : UINT_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)uint_values[i]));
    actual.value = convert_short8((uint8)uint_values[i]);
    compare_short_elements("convert_short8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((uint8)uint_values[i]);
    compare_short_elements("convert_short8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (SHRT_MIN > 0) ? (uint)SHRT_MIN : 0;
    const uint max_expected = (SHRT_MAX < UINT_MAX) ? (uint)SHRT_MAX : UINT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)uint_values[i]));
    actual.value = convert_short16((uint16)uint_values[i]);
    compare_short_elements("convert_short16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((uint16)uint_values[i]);
    compare_short_elements("convert_short16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (USHRT_MAX < UINT_MAX) ? (uint)USHRT_MAX : UINT_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)uint_values[i]));
    actual.value = convert_ushort((uint)uint_values[i]);
    compare_ushort_elements("convert_ushort((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((uint)uint_values[i]);
    compare_ushort_elements("convert_ushort_sat((uint))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (USHRT_MAX < UINT_MAX) ? (uint)USHRT_MAX : UINT_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)uint_values[i]));
    actual.value = convert_ushort2((uint2)uint_values[i]);
    compare_ushort_elements("convert_ushort2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((uint2)uint_values[i]);
    compare_ushort_elements("convert_ushort2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (USHRT_MAX < UINT_MAX) ? (uint)USHRT_MAX : UINT_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)uint_values[i]));
    actual.value = convert_ushort4((uint4)uint_values[i]);
    compare_ushort_elements("convert_ushort4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((uint4)uint_values[i]);
    compare_ushort_elements("convert_ushort4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (USHRT_MAX < UINT_MAX) ? (uint)USHRT_MAX : UINT_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)uint_values[i]));
    actual.value = convert_ushort8((uint8)uint_values[i]);
    compare_ushort_elements("convert_ushort8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((uint8)uint_values[i]);
    compare_ushort_elements("convert_ushort8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (USHRT_MAX < UINT_MAX) ? (uint)USHRT_MAX : UINT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)uint_values[i]));
    actual.value = convert_ushort16((uint16)uint_values[i]);
    compare_ushort_elements("convert_ushort16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((uint16)uint_values[i]);
    compare_ushort_elements("convert_ushort16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (INT_MIN > 0) ? (uint)INT_MIN : 0;
    const uint max_expected = (INT_MAX < UINT_MAX) ? (uint)INT_MAX : UINT_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)uint_values[i]));
    actual.value = convert_int((uint)uint_values[i]);
    compare_int_elements("convert_int((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((uint)uint_values[i]);
    compare_int_elements("convert_int_sat((uint))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (INT_MIN > 0) ? (uint)INT_MIN : 0;
    const uint max_expected = (INT_MAX < UINT_MAX) ? (uint)INT_MAX : UINT_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)uint_values[i]));
    actual.value = convert_int2((uint2)uint_values[i]);
    compare_int_elements("convert_int2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((uint2)uint_values[i]);
    compare_int_elements("convert_int2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (INT_MIN > 0) ? (uint)INT_MIN : 0;
    const uint max_expected = (INT_MAX < UINT_MAX) ? (uint)INT_MAX : UINT_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)uint_values[i]));
    actual.value = convert_int4((uint4)uint_values[i]);
    compare_int_elements("convert_int4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((uint4)uint_values[i]);
    compare_int_elements("convert_int4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (INT_MIN > 0) ? (uint)INT_MIN : 0;
    const uint max_expected = (INT_MAX < UINT_MAX) ? (uint)INT_MAX : UINT_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)uint_values[i]));
    actual.value = convert_int8((uint8)uint_values[i]);
    compare_int_elements("convert_int8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((uint8)uint_values[i]);
    compare_int_elements("convert_int8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (INT_MIN > 0) ? (uint)INT_MIN : 0;
    const uint max_expected = (INT_MAX < UINT_MAX) ? (uint)INT_MAX : UINT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)uint_values[i]));
    actual.value = convert_int16((uint16)uint_values[i]);
    compare_int_elements("convert_int16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((uint16)uint_values[i]);
    compare_int_elements("convert_int16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UINT_MAX < UINT_MAX) ? (uint)UINT_MAX : UINT_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)uint_values[i]));
    actual.value = convert_uint((uint)uint_values[i]);
    compare_uint_elements("convert_uint((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((uint)uint_values[i]);
    compare_uint_elements("convert_uint_sat((uint))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UINT_MAX < UINT_MAX) ? (uint)UINT_MAX : UINT_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)uint_values[i]));
    actual.value = convert_uint2((uint2)uint_values[i]);
    compare_uint_elements("convert_uint2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((uint2)uint_values[i]);
    compare_uint_elements("convert_uint2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UINT_MAX < UINT_MAX) ? (uint)UINT_MAX : UINT_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)uint_values[i]));
    actual.value = convert_uint4((uint4)uint_values[i]);
    compare_uint_elements("convert_uint4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((uint4)uint_values[i]);
    compare_uint_elements("convert_uint4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UINT_MAX < UINT_MAX) ? (uint)UINT_MAX : UINT_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)uint_values[i]));
    actual.value = convert_uint8((uint8)uint_values[i]);
    compare_uint_elements("convert_uint8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((uint8)uint_values[i]);
    compare_uint_elements("convert_uint8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (UINT_MAX < UINT_MAX) ? (uint)UINT_MAX : UINT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)uint_values[i]));
    actual.value = convert_uint16((uint16)uint_values[i]);
    compare_uint_elements("convert_uint16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((uint16)uint_values[i]);
    compare_uint_elements("convert_uint16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (LONG_MIN > 0) ? (uint)LONG_MIN : 0;
    const uint max_expected = (LONG_MAX < UINT_MAX) ? (uint)LONG_MAX : UINT_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)uint_values[i]));
    actual.value = convert_long((uint)uint_values[i]);
    compare_long_elements("convert_long((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((uint)uint_values[i]);
    compare_long_elements("convert_long_sat((uint))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (LONG_MIN > 0) ? (uint)LONG_MIN : 0;
    const uint max_expected = (LONG_MAX < UINT_MAX) ? (uint)LONG_MAX : UINT_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)uint_values[i]));
    actual.value = convert_long2((uint2)uint_values[i]);
    compare_long_elements("convert_long2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((uint2)uint_values[i]);
    compare_long_elements("convert_long2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (LONG_MIN > 0) ? (uint)LONG_MIN : 0;
    const uint max_expected = (LONG_MAX < UINT_MAX) ? (uint)LONG_MAX : UINT_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)uint_values[i]));
    actual.value = convert_long4((uint4)uint_values[i]);
    compare_long_elements("convert_long4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((uint4)uint_values[i]);
    compare_long_elements("convert_long4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (LONG_MIN > 0) ? (uint)LONG_MIN : 0;
    const uint max_expected = (LONG_MAX < UINT_MAX) ? (uint)LONG_MAX : UINT_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)uint_values[i]));
    actual.value = convert_long8((uint8)uint_values[i]);
    compare_long_elements("convert_long8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((uint8)uint_values[i]);
    compare_long_elements("convert_long8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (LONG_MIN > 0) ? (uint)LONG_MIN : 0;
    const uint max_expected = (LONG_MAX < UINT_MAX) ? (uint)LONG_MAX : UINT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)uint_values[i]));
    actual.value = convert_long16((uint16)uint_values[i]);
    compare_long_elements("convert_long16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((uint16)uint_values[i]);
    compare_long_elements("convert_long16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (ULONG_MAX < UINT_MAX) ? (uint)ULONG_MAX : UINT_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)uint_values[i]));
    actual.value = convert_ulong((uint)uint_values[i]);
    compare_ulong_elements("convert_ulong((uint))", i, expected.raw, actual.raw, 1);
    if (uint_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((uint)uint_values[i]);
    compare_ulong_elements("convert_ulong_sat((uint))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (ULONG_MAX < UINT_MAX) ? (uint)ULONG_MAX : UINT_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)uint_values[i]));
    actual.value = convert_ulong2((uint2)uint_values[i]);
    compare_ulong_elements("convert_ulong2((uint2))", i, expected.raw, actual.raw, 2);
    if (uint_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((uint2)uint_values[i]);
    compare_ulong_elements("convert_ulong2_sat((uint2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (ULONG_MAX < UINT_MAX) ? (uint)ULONG_MAX : UINT_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)uint_values[i]));
    actual.value = convert_ulong4((uint4)uint_values[i]);
    compare_ulong_elements("convert_ulong4((uint4))", i, expected.raw, actual.raw, 4);
    if (uint_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((uint4)uint_values[i]);
    compare_ulong_elements("convert_ulong4_sat((uint4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (ULONG_MAX < UINT_MAX) ? (uint)ULONG_MAX : UINT_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)uint_values[i]));
    actual.value = convert_ulong8((uint8)uint_values[i]);
    compare_ulong_elements("convert_ulong8((uint8))", i, expected.raw, actual.raw, 8);
    if (uint_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((uint8)uint_values[i]);
    compare_ulong_elements("convert_ulong8_sat((uint8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (0 > 0) ? (uint)0 : 0;
    const uint max_expected = (ULONG_MAX < UINT_MAX) ? (uint)ULONG_MAX : UINT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)uint_values[i]));
    actual.value = convert_ulong16((uint16)uint_values[i]);
    compare_ulong_elements("convert_ulong16((uint16))", i, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((uint16)uint_values[i]);
    compare_ulong_elements("convert_ulong16_sat((uint16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (CHAR_MIN > LONG_MIN) ? (long)CHAR_MIN : LONG_MIN;
    const long max_expected = (CHAR_MAX < LONG_MAX) ? (long)CHAR_MAX : LONG_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)long_values[i]));
    actual.value = convert_char((long)long_values[i]);
    compare_char_elements("convert_char((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((long)long_values[i]);
    compare_char_elements("convert_char_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (CHAR_MIN > LONG_MIN) ? (long)CHAR_MIN : LONG_MIN;
    const long max_expected = (CHAR_MAX < LONG_MAX) ? (long)CHAR_MAX : LONG_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)long_values[i]));
    actual.value = convert_char2((long2)long_values[i]);
    compare_char_elements("convert_char2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((long2)long_values[i]);
    compare_char_elements("convert_char2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (CHAR_MIN > LONG_MIN) ? (long)CHAR_MIN : LONG_MIN;
    const long max_expected = (CHAR_MAX < LONG_MAX) ? (long)CHAR_MAX : LONG_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)long_values[i]));
    actual.value = convert_char4((long4)long_values[i]);
    compare_char_elements("convert_char4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((long4)long_values[i]);
    compare_char_elements("convert_char4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (CHAR_MIN > LONG_MIN) ? (long)CHAR_MIN : LONG_MIN;
    const long max_expected = (CHAR_MAX < LONG_MAX) ? (long)CHAR_MAX : LONG_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)long_values[i]));
    actual.value = convert_char8((long8)long_values[i]);
    compare_char_elements("convert_char8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((long8)long_values[i]);
    compare_char_elements("convert_char8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (CHAR_MIN > LONG_MIN) ? (long)CHAR_MIN : LONG_MIN;
    const long max_expected = (CHAR_MAX < LONG_MAX) ? (long)CHAR_MAX : LONG_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)long_values[i]));
    actual.value = convert_char16((long16)long_values[i]);
    compare_char_elements("convert_char16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((long16)long_values[i]);
    compare_char_elements("convert_char16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UCHAR_MAX < LONG_MAX) ? (long)UCHAR_MAX : LONG_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)long_values[i]));
    actual.value = convert_uchar((long)long_values[i]);
    compare_uchar_elements("convert_uchar((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((long)long_values[i]);
    compare_uchar_elements("convert_uchar_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UCHAR_MAX < LONG_MAX) ? (long)UCHAR_MAX : LONG_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)long_values[i]));
    actual.value = convert_uchar2((long2)long_values[i]);
    compare_uchar_elements("convert_uchar2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((long2)long_values[i]);
    compare_uchar_elements("convert_uchar2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UCHAR_MAX < LONG_MAX) ? (long)UCHAR_MAX : LONG_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)long_values[i]));
    actual.value = convert_uchar4((long4)long_values[i]);
    compare_uchar_elements("convert_uchar4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((long4)long_values[i]);
    compare_uchar_elements("convert_uchar4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UCHAR_MAX < LONG_MAX) ? (long)UCHAR_MAX : LONG_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)long_values[i]));
    actual.value = convert_uchar8((long8)long_values[i]);
    compare_uchar_elements("convert_uchar8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((long8)long_values[i]);
    compare_uchar_elements("convert_uchar8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UCHAR_MAX < LONG_MAX) ? (long)UCHAR_MAX : LONG_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)long_values[i]));
    actual.value = convert_uchar16((long16)long_values[i]);
    compare_uchar_elements("convert_uchar16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((long16)long_values[i]);
    compare_uchar_elements("convert_uchar16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (SHRT_MIN > LONG_MIN) ? (long)SHRT_MIN : LONG_MIN;
    const long max_expected = (SHRT_MAX < LONG_MAX) ? (long)SHRT_MAX : LONG_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)long_values[i]));
    actual.value = convert_short((long)long_values[i]);
    compare_short_elements("convert_short((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((long)long_values[i]);
    compare_short_elements("convert_short_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (SHRT_MIN > LONG_MIN) ? (long)SHRT_MIN : LONG_MIN;
    const long max_expected = (SHRT_MAX < LONG_MAX) ? (long)SHRT_MAX : LONG_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)long_values[i]));
    actual.value = convert_short2((long2)long_values[i]);
    compare_short_elements("convert_short2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((long2)long_values[i]);
    compare_short_elements("convert_short2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (SHRT_MIN > LONG_MIN) ? (long)SHRT_MIN : LONG_MIN;
    const long max_expected = (SHRT_MAX < LONG_MAX) ? (long)SHRT_MAX : LONG_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)long_values[i]));
    actual.value = convert_short4((long4)long_values[i]);
    compare_short_elements("convert_short4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((long4)long_values[i]);
    compare_short_elements("convert_short4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (SHRT_MIN > LONG_MIN) ? (long)SHRT_MIN : LONG_MIN;
    const long max_expected = (SHRT_MAX < LONG_MAX) ? (long)SHRT_MAX : LONG_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)long_values[i]));
    actual.value = convert_short8((long8)long_values[i]);
    compare_short_elements("convert_short8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((long8)long_values[i]);
    compare_short_elements("convert_short8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (SHRT_MIN > LONG_MIN) ? (long)SHRT_MIN : LONG_MIN;
    const long max_expected = (SHRT_MAX < LONG_MAX) ? (long)SHRT_MAX : LONG_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)long_values[i]));
    actual.value = convert_short16((long16)long_values[i]);
    compare_short_elements("convert_short16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((long16)long_values[i]);
    compare_short_elements("convert_short16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (USHRT_MAX < LONG_MAX) ? (long)USHRT_MAX : LONG_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)long_values[i]));
    actual.value = convert_ushort((long)long_values[i]);
    compare_ushort_elements("convert_ushort((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((long)long_values[i]);
    compare_ushort_elements("convert_ushort_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (USHRT_MAX < LONG_MAX) ? (long)USHRT_MAX : LONG_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)long_values[i]));
    actual.value = convert_ushort2((long2)long_values[i]);
    compare_ushort_elements("convert_ushort2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((long2)long_values[i]);
    compare_ushort_elements("convert_ushort2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (USHRT_MAX < LONG_MAX) ? (long)USHRT_MAX : LONG_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)long_values[i]));
    actual.value = convert_ushort4((long4)long_values[i]);
    compare_ushort_elements("convert_ushort4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((long4)long_values[i]);
    compare_ushort_elements("convert_ushort4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (USHRT_MAX < LONG_MAX) ? (long)USHRT_MAX : LONG_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)long_values[i]));
    actual.value = convert_ushort8((long8)long_values[i]);
    compare_ushort_elements("convert_ushort8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((long8)long_values[i]);
    compare_ushort_elements("convert_ushort8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (USHRT_MAX < LONG_MAX) ? (long)USHRT_MAX : LONG_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)long_values[i]));
    actual.value = convert_ushort16((long16)long_values[i]);
    compare_ushort_elements("convert_ushort16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((long16)long_values[i]);
    compare_ushort_elements("convert_ushort16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (INT_MIN > LONG_MIN) ? (long)INT_MIN : LONG_MIN;
    const long max_expected = (INT_MAX < LONG_MAX) ? (long)INT_MAX : LONG_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)long_values[i]));
    actual.value = convert_int((long)long_values[i]);
    compare_int_elements("convert_int((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((long)long_values[i]);
    compare_int_elements("convert_int_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (INT_MIN > LONG_MIN) ? (long)INT_MIN : LONG_MIN;
    const long max_expected = (INT_MAX < LONG_MAX) ? (long)INT_MAX : LONG_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)long_values[i]));
    actual.value = convert_int2((long2)long_values[i]);
    compare_int_elements("convert_int2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((long2)long_values[i]);
    compare_int_elements("convert_int2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (INT_MIN > LONG_MIN) ? (long)INT_MIN : LONG_MIN;
    const long max_expected = (INT_MAX < LONG_MAX) ? (long)INT_MAX : LONG_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)long_values[i]));
    actual.value = convert_int4((long4)long_values[i]);
    compare_int_elements("convert_int4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((long4)long_values[i]);
    compare_int_elements("convert_int4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (INT_MIN > LONG_MIN) ? (long)INT_MIN : LONG_MIN;
    const long max_expected = (INT_MAX < LONG_MAX) ? (long)INT_MAX : LONG_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)long_values[i]));
    actual.value = convert_int8((long8)long_values[i]);
    compare_int_elements("convert_int8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((long8)long_values[i]);
    compare_int_elements("convert_int8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (INT_MIN > LONG_MIN) ? (long)INT_MIN : LONG_MIN;
    const long max_expected = (INT_MAX < LONG_MAX) ? (long)INT_MAX : LONG_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)long_values[i]));
    actual.value = convert_int16((long16)long_values[i]);
    compare_int_elements("convert_int16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((long16)long_values[i]);
    compare_int_elements("convert_int16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UINT_MAX < LONG_MAX) ? (long)UINT_MAX : LONG_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)long_values[i]));
    actual.value = convert_uint((long)long_values[i]);
    compare_uint_elements("convert_uint((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((long)long_values[i]);
    compare_uint_elements("convert_uint_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UINT_MAX < LONG_MAX) ? (long)UINT_MAX : LONG_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)long_values[i]));
    actual.value = convert_uint2((long2)long_values[i]);
    compare_uint_elements("convert_uint2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((long2)long_values[i]);
    compare_uint_elements("convert_uint2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UINT_MAX < LONG_MAX) ? (long)UINT_MAX : LONG_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)long_values[i]));
    actual.value = convert_uint4((long4)long_values[i]);
    compare_uint_elements("convert_uint4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((long4)long_values[i]);
    compare_uint_elements("convert_uint4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UINT_MAX < LONG_MAX) ? (long)UINT_MAX : LONG_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)long_values[i]));
    actual.value = convert_uint8((long8)long_values[i]);
    compare_uint_elements("convert_uint8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((long8)long_values[i]);
    compare_uint_elements("convert_uint8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (UINT_MAX < LONG_MAX) ? (long)UINT_MAX : LONG_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)long_values[i]));
    actual.value = convert_uint16((long16)long_values[i]);
    compare_uint_elements("convert_uint16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((long16)long_values[i]);
    compare_uint_elements("convert_uint16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (LONG_MIN > LONG_MIN) ? (long)LONG_MIN : LONG_MIN;
    const long max_expected = (LONG_MAX < LONG_MAX) ? (long)LONG_MAX : LONG_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)long_values[i]));
    actual.value = convert_long((long)long_values[i]);
    compare_long_elements("convert_long((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((long)long_values[i]);
    compare_long_elements("convert_long_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (LONG_MIN > LONG_MIN) ? (long)LONG_MIN : LONG_MIN;
    const long max_expected = (LONG_MAX < LONG_MAX) ? (long)LONG_MAX : LONG_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)long_values[i]));
    actual.value = convert_long2((long2)long_values[i]);
    compare_long_elements("convert_long2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((long2)long_values[i]);
    compare_long_elements("convert_long2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (LONG_MIN > LONG_MIN) ? (long)LONG_MIN : LONG_MIN;
    const long max_expected = (LONG_MAX < LONG_MAX) ? (long)LONG_MAX : LONG_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)long_values[i]));
    actual.value = convert_long4((long4)long_values[i]);
    compare_long_elements("convert_long4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((long4)long_values[i]);
    compare_long_elements("convert_long4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (LONG_MIN > LONG_MIN) ? (long)LONG_MIN : LONG_MIN;
    const long max_expected = (LONG_MAX < LONG_MAX) ? (long)LONG_MAX : LONG_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)long_values[i]));
    actual.value = convert_long8((long8)long_values[i]);
    compare_long_elements("convert_long8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((long8)long_values[i]);
    compare_long_elements("convert_long8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (LONG_MIN > LONG_MIN) ? (long)LONG_MIN : LONG_MIN;
    const long max_expected = (LONG_MAX < LONG_MAX) ? (long)LONG_MAX : LONG_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)long_values[i]));
    actual.value = convert_long16((long16)long_values[i]);
    compare_long_elements("convert_long16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((long16)long_values[i]);
    compare_long_elements("convert_long16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (ULONG_MAX < LONG_MAX) ? (long)ULONG_MAX : LONG_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)long_values[i]));
    actual.value = convert_ulong((long)long_values[i]);
    compare_ulong_elements("convert_ulong((long))", i, expected.raw, actual.raw, 1);
    if (long_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((long)long_values[i]);
    compare_ulong_elements("convert_ulong_sat((long))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (ULONG_MAX < LONG_MAX) ? (long)ULONG_MAX : LONG_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)long_values[i]));
    actual.value = convert_ulong2((long2)long_values[i]);
    compare_ulong_elements("convert_ulong2((long2))", i, expected.raw, actual.raw, 2);
    if (long_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((long2)long_values[i]);
    compare_ulong_elements("convert_ulong2_sat((long2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (ULONG_MAX < LONG_MAX) ? (long)ULONG_MAX : LONG_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)long_values[i]));
    actual.value = convert_ulong4((long4)long_values[i]);
    compare_ulong_elements("convert_ulong4((long4))", i, expected.raw, actual.raw, 4);
    if (long_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((long4)long_values[i]);
    compare_ulong_elements("convert_ulong4_sat((long4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (ULONG_MAX < LONG_MAX) ? (long)ULONG_MAX : LONG_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)long_values[i]));
    actual.value = convert_ulong8((long8)long_values[i]);
    compare_ulong_elements("convert_ulong8((long8))", i, expected.raw, actual.raw, 8);
    if (long_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((long8)long_values[i]);
    compare_ulong_elements("convert_ulong8_sat((long8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (ULONG_MAX < LONG_MAX) ? (long)ULONG_MAX : LONG_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)long_values[i]));
    actual.value = convert_ulong16((long16)long_values[i]);
    compare_ulong_elements("convert_ulong16((long16))", i, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((long16)long_values[i]);
    compare_ulong_elements("convert_ulong16_sat((long16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (CHAR_MIN > 0) ? (ulong)CHAR_MIN : 0;
    const ulong max_expected = (CHAR_MAX < ULONG_MAX) ? (ulong)CHAR_MAX : ULONG_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)ulong_values[i]));
    actual.value = convert_char((ulong)ulong_values[i]);
    compare_char_elements("convert_char((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((ulong)ulong_values[i]);
    compare_char_elements("convert_char_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (CHAR_MIN > 0) ? (ulong)CHAR_MIN : 0;
    const ulong max_expected = (CHAR_MAX < ULONG_MAX) ? (ulong)CHAR_MAX : ULONG_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)ulong_values[i]));
    actual.value = convert_char2((ulong2)ulong_values[i]);
    compare_char_elements("convert_char2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((ulong2)ulong_values[i]);
    compare_char_elements("convert_char2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (CHAR_MIN > 0) ? (ulong)CHAR_MIN : 0;
    const ulong max_expected = (CHAR_MAX < ULONG_MAX) ? (ulong)CHAR_MAX : ULONG_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)ulong_values[i]));
    actual.value = convert_char4((ulong4)ulong_values[i]);
    compare_char_elements("convert_char4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((ulong4)ulong_values[i]);
    compare_char_elements("convert_char4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (CHAR_MIN > 0) ? (ulong)CHAR_MIN : 0;
    const ulong max_expected = (CHAR_MAX < ULONG_MAX) ? (ulong)CHAR_MAX : ULONG_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)ulong_values[i]));
    actual.value = convert_char8((ulong8)ulong_values[i]);
    compare_char_elements("convert_char8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((ulong8)ulong_values[i]);
    compare_char_elements("convert_char8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (CHAR_MIN > 0) ? (ulong)CHAR_MIN : 0;
    const ulong max_expected = (CHAR_MAX < ULONG_MAX) ? (ulong)CHAR_MAX : ULONG_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)ulong_values[i]));
    actual.value = convert_char16((ulong16)ulong_values[i]);
    compare_char_elements("convert_char16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((ulong16)ulong_values[i]);
    compare_char_elements("convert_char16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UCHAR_MAX < ULONG_MAX) ? (ulong)UCHAR_MAX : ULONG_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)ulong_values[i]));
    actual.value = convert_uchar((ulong)ulong_values[i]);
    compare_uchar_elements("convert_uchar((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((ulong)ulong_values[i]);
    compare_uchar_elements("convert_uchar_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UCHAR_MAX < ULONG_MAX) ? (ulong)UCHAR_MAX : ULONG_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)ulong_values[i]));
    actual.value = convert_uchar2((ulong2)ulong_values[i]);
    compare_uchar_elements("convert_uchar2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((ulong2)ulong_values[i]);
    compare_uchar_elements("convert_uchar2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UCHAR_MAX < ULONG_MAX) ? (ulong)UCHAR_MAX : ULONG_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)ulong_values[i]));
    actual.value = convert_uchar4((ulong4)ulong_values[i]);
    compare_uchar_elements("convert_uchar4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((ulong4)ulong_values[i]);
    compare_uchar_elements("convert_uchar4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UCHAR_MAX < ULONG_MAX) ? (ulong)UCHAR_MAX : ULONG_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)ulong_values[i]));
    actual.value = convert_uchar8((ulong8)ulong_values[i]);
    compare_uchar_elements("convert_uchar8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((ulong8)ulong_values[i]);
    compare_uchar_elements("convert_uchar8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UCHAR_MAX < ULONG_MAX) ? (ulong)UCHAR_MAX : ULONG_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)ulong_values[i]));
    actual.value = convert_uchar16((ulong16)ulong_values[i]);
    compare_uchar_elements("convert_uchar16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((ulong16)ulong_values[i]);
    compare_uchar_elements("convert_uchar16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (SHRT_MIN > 0) ? (ulong)SHRT_MIN : 0;
    const ulong max_expected = (SHRT_MAX < ULONG_MAX) ? (ulong)SHRT_MAX : ULONG_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)ulong_values[i]));
    actual.value = convert_short((ulong)ulong_values[i]);
    compare_short_elements("convert_short((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((ulong)ulong_values[i]);
    compare_short_elements("convert_short_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (SHRT_MIN > 0) ? (ulong)SHRT_MIN : 0;
    const ulong max_expected = (SHRT_MAX < ULONG_MAX) ? (ulong)SHRT_MAX : ULONG_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)ulong_values[i]));
    actual.value = convert_short2((ulong2)ulong_values[i]);
    compare_short_elements("convert_short2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((ulong2)ulong_values[i]);
    compare_short_elements("convert_short2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (SHRT_MIN > 0) ? (ulong)SHRT_MIN : 0;
    const ulong max_expected = (SHRT_MAX < ULONG_MAX) ? (ulong)SHRT_MAX : ULONG_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)ulong_values[i]));
    actual.value = convert_short4((ulong4)ulong_values[i]);
    compare_short_elements("convert_short4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((ulong4)ulong_values[i]);
    compare_short_elements("convert_short4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (SHRT_MIN > 0) ? (ulong)SHRT_MIN : 0;
    const ulong max_expected = (SHRT_MAX < ULONG_MAX) ? (ulong)SHRT_MAX : ULONG_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)ulong_values[i]));
    actual.value = convert_short8((ulong8)ulong_values[i]);
    compare_short_elements("convert_short8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((ulong8)ulong_values[i]);
    compare_short_elements("convert_short8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (SHRT_MIN > 0) ? (ulong)SHRT_MIN : 0;
    const ulong max_expected = (SHRT_MAX < ULONG_MAX) ? (ulong)SHRT_MAX : ULONG_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)ulong_values[i]));
    actual.value = convert_short16((ulong16)ulong_values[i]);
    compare_short_elements("convert_short16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((ulong16)ulong_values[i]);
    compare_short_elements("convert_short16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (USHRT_MAX < ULONG_MAX) ? (ulong)USHRT_MAX : ULONG_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)ulong_values[i]));
    actual.value = convert_ushort((ulong)ulong_values[i]);
    compare_ushort_elements("convert_ushort((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((ulong)ulong_values[i]);
    compare_ushort_elements("convert_ushort_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (USHRT_MAX < ULONG_MAX) ? (ulong)USHRT_MAX : ULONG_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)ulong_values[i]));
    actual.value = convert_ushort2((ulong2)ulong_values[i]);
    compare_ushort_elements("convert_ushort2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((ulong2)ulong_values[i]);
    compare_ushort_elements("convert_ushort2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (USHRT_MAX < ULONG_MAX) ? (ulong)USHRT_MAX : ULONG_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)ulong_values[i]));
    actual.value = convert_ushort4((ulong4)ulong_values[i]);
    compare_ushort_elements("convert_ushort4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((ulong4)ulong_values[i]);
    compare_ushort_elements("convert_ushort4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (USHRT_MAX < ULONG_MAX) ? (ulong)USHRT_MAX : ULONG_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)ulong_values[i]));
    actual.value = convert_ushort8((ulong8)ulong_values[i]);
    compare_ushort_elements("convert_ushort8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((ulong8)ulong_values[i]);
    compare_ushort_elements("convert_ushort8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (USHRT_MAX < ULONG_MAX) ? (ulong)USHRT_MAX : ULONG_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)ulong_values[i]));
    actual.value = convert_ushort16((ulong16)ulong_values[i]);
    compare_ushort_elements("convert_ushort16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((ulong16)ulong_values[i]);
    compare_ushort_elements("convert_ushort16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (INT_MIN > 0) ? (ulong)INT_MIN : 0;
    const ulong max_expected = (INT_MAX < ULONG_MAX) ? (ulong)INT_MAX : ULONG_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)ulong_values[i]));
    actual.value = convert_int((ulong)ulong_values[i]);
    compare_int_elements("convert_int((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((ulong)ulong_values[i]);
    compare_int_elements("convert_int_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (INT_MIN > 0) ? (ulong)INT_MIN : 0;
    const ulong max_expected = (INT_MAX < ULONG_MAX) ? (ulong)INT_MAX : ULONG_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)ulong_values[i]));
    actual.value = convert_int2((ulong2)ulong_values[i]);
    compare_int_elements("convert_int2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((ulong2)ulong_values[i]);
    compare_int_elements("convert_int2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (INT_MIN > 0) ? (ulong)INT_MIN : 0;
    const ulong max_expected = (INT_MAX < ULONG_MAX) ? (ulong)INT_MAX : ULONG_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)ulong_values[i]));
    actual.value = convert_int4((ulong4)ulong_values[i]);
    compare_int_elements("convert_int4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((ulong4)ulong_values[i]);
    compare_int_elements("convert_int4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (INT_MIN > 0) ? (ulong)INT_MIN : 0;
    const ulong max_expected = (INT_MAX < ULONG_MAX) ? (ulong)INT_MAX : ULONG_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)ulong_values[i]));
    actual.value = convert_int8((ulong8)ulong_values[i]);
    compare_int_elements("convert_int8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((ulong8)ulong_values[i]);
    compare_int_elements("convert_int8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (INT_MIN > 0) ? (ulong)INT_MIN : 0;
    const ulong max_expected = (INT_MAX < ULONG_MAX) ? (ulong)INT_MAX : ULONG_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)ulong_values[i]));
    actual.value = convert_int16((ulong16)ulong_values[i]);
    compare_int_elements("convert_int16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((ulong16)ulong_values[i]);
    compare_int_elements("convert_int16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UINT_MAX < ULONG_MAX) ? (ulong)UINT_MAX : ULONG_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)ulong_values[i]));
    actual.value = convert_uint((ulong)ulong_values[i]);
    compare_uint_elements("convert_uint((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((ulong)ulong_values[i]);
    compare_uint_elements("convert_uint_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UINT_MAX < ULONG_MAX) ? (ulong)UINT_MAX : ULONG_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)ulong_values[i]));
    actual.value = convert_uint2((ulong2)ulong_values[i]);
    compare_uint_elements("convert_uint2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((ulong2)ulong_values[i]);
    compare_uint_elements("convert_uint2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UINT_MAX < ULONG_MAX) ? (ulong)UINT_MAX : ULONG_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)ulong_values[i]));
    actual.value = convert_uint4((ulong4)ulong_values[i]);
    compare_uint_elements("convert_uint4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((ulong4)ulong_values[i]);
    compare_uint_elements("convert_uint4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UINT_MAX < ULONG_MAX) ? (ulong)UINT_MAX : ULONG_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)ulong_values[i]));
    actual.value = convert_uint8((ulong8)ulong_values[i]);
    compare_uint_elements("convert_uint8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((ulong8)ulong_values[i]);
    compare_uint_elements("convert_uint8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (UINT_MAX < ULONG_MAX) ? (ulong)UINT_MAX : ULONG_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)ulong_values[i]));
    actual.value = convert_uint16((ulong16)ulong_values[i]);
    compare_uint_elements("convert_uint16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((ulong16)ulong_values[i]);
    compare_uint_elements("convert_uint16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (LONG_MIN > 0) ? (ulong)LONG_MIN : 0;
    const ulong max_expected = (LONG_MAX < ULONG_MAX) ? (ulong)LONG_MAX : ULONG_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)ulong_values[i]));
    actual.value = convert_long((ulong)ulong_values[i]);
    compare_long_elements("convert_long((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((ulong)ulong_values[i]);
    compare_long_elements("convert_long_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (LONG_MIN > 0) ? (ulong)LONG_MIN : 0;
    const ulong max_expected = (LONG_MAX < ULONG_MAX) ? (ulong)LONG_MAX : ULONG_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)ulong_values[i]));
    actual.value = convert_long2((ulong2)ulong_values[i]);
    compare_long_elements("convert_long2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((ulong2)ulong_values[i]);
    compare_long_elements("convert_long2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (LONG_MIN > 0) ? (ulong)LONG_MIN : 0;
    const ulong max_expected = (LONG_MAX < ULONG_MAX) ? (ulong)LONG_MAX : ULONG_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)ulong_values[i]));
    actual.value = convert_long4((ulong4)ulong_values[i]);
    compare_long_elements("convert_long4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((ulong4)ulong_values[i]);
    compare_long_elements("convert_long4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (LONG_MIN > 0) ? (ulong)LONG_MIN : 0;
    const ulong max_expected = (LONG_MAX < ULONG_MAX) ? (ulong)LONG_MAX : ULONG_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)ulong_values[i]));
    actual.value = convert_long8((ulong8)ulong_values[i]);
    compare_long_elements("convert_long8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((ulong8)ulong_values[i]);
    compare_long_elements("convert_long8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (LONG_MIN > 0) ? (ulong)LONG_MIN : 0;
    const ulong max_expected = (LONG_MAX < ULONG_MAX) ? (ulong)LONG_MAX : ULONG_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)ulong_values[i]));
    actual.value = convert_long16((ulong16)ulong_values[i]);
    compare_long_elements("convert_long16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((ulong16)ulong_values[i]);
    compare_long_elements("convert_long16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ULONG_MAX < ULONG_MAX) ? (ulong)ULONG_MAX : ULONG_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)ulong_values[i]));
    actual.value = convert_ulong((ulong)ulong_values[i]);
    compare_ulong_elements("convert_ulong((ulong))", i, expected.raw, actual.raw, 1);
    if (ulong_values[i] < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((ulong)ulong_values[i]);
    compare_ulong_elements("convert_ulong_sat((ulong))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ULONG_MAX < ULONG_MAX) ? (ulong)ULONG_MAX : ULONG_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)ulong_values[i]));
    actual.value = convert_ulong2((ulong2)ulong_values[i]);
    compare_ulong_elements("convert_ulong2((ulong2))", i, expected.raw, actual.raw, 2);
    if (ulong_values[i] < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((ulong2)ulong_values[i]);
    compare_ulong_elements("convert_ulong2_sat((ulong2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ULONG_MAX < ULONG_MAX) ? (ulong)ULONG_MAX : ULONG_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)ulong_values[i]));
    actual.value = convert_ulong4((ulong4)ulong_values[i]);
    compare_ulong_elements("convert_ulong4((ulong4))", i, expected.raw, actual.raw, 4);
    if (ulong_values[i] < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((ulong4)ulong_values[i]);
    compare_ulong_elements("convert_ulong4_sat((ulong4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ULONG_MAX < ULONG_MAX) ? (ulong)ULONG_MAX : ULONG_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)ulong_values[i]));
    actual.value = convert_ulong8((ulong8)ulong_values[i]);
    compare_ulong_elements("convert_ulong8((ulong8))", i, expected.raw, actual.raw, 8);
    if (ulong_values[i] < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((ulong8)ulong_values[i]);
    compare_ulong_elements("convert_ulong8_sat((ulong8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ULONG_MAX < ULONG_MAX) ? (ulong)ULONG_MAX : ULONG_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)ulong_values[i]));
    actual.value = convert_ulong16((ulong16)ulong_values[i]);
    compare_ulong_elements("convert_ulong16((ulong16))", i, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((ulong16)ulong_values[i]);
    compare_ulong_elements("convert_ulong16_sat((ulong16))", i, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (CHAR_MIN > -FLT_MAX) ? (float)CHAR_MIN : -FLT_MAX;
    const float max_expected = (CHAR_MAX < FLT_MAX) ? (float)CHAR_MAX : FLT_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)float_rounded_values[i]));
    actual.value = convert_char((float)float_values[i]);
    compare_char_elements("convert_char((float))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((float)sat_input);
    compare_char_elements("convert_char_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)float_rounded_values_rte[i]));
    actual.value = convert_char_rte((float)float_values[i]);
    compare_char_elements("convert_char_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rte((float)sat_input);
    compare_char_elements("convert_char_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)float_rounded_values_rtz[i]));
    actual.value = convert_char_rtz((float)float_values[i]);
    compare_char_elements("convert_char_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rtz((float)sat_input);
    compare_char_elements("convert_char_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)float_rounded_values_rtp[i]));
    actual.value = convert_char_rtp((float)float_values[i]);
    compare_char_elements("convert_char_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rtp((float)sat_input);
    compare_char_elements("convert_char_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)float_rounded_values_rtn[i]));
    actual.value = convert_char_rtn((float)float_values[i]);
    compare_char_elements("convert_char_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rtn((float)sat_input);
    compare_char_elements("convert_char_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (CHAR_MIN > -FLT_MAX) ? (float)CHAR_MIN : -FLT_MAX;
    const float max_expected = (CHAR_MAX < FLT_MAX) ? (float)CHAR_MAX : FLT_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)float_rounded_values[i]));
    actual.value = convert_char2((float2)float_values[i]);
    compare_char_elements("convert_char2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((float2)sat_input);
    compare_char_elements("convert_char2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)float_rounded_values_rte[i]));
    actual.value = convert_char2_rte((float2)float_values[i]);
    compare_char_elements("convert_char2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rte((float2)sat_input);
    compare_char_elements("convert_char2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)float_rounded_values_rtz[i]));
    actual.value = convert_char2_rtz((float2)float_values[i]);
    compare_char_elements("convert_char2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rtz((float2)sat_input);
    compare_char_elements("convert_char2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)float_rounded_values_rtp[i]));
    actual.value = convert_char2_rtp((float2)float_values[i]);
    compare_char_elements("convert_char2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rtp((float2)sat_input);
    compare_char_elements("convert_char2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)float_rounded_values_rtn[i]));
    actual.value = convert_char2_rtn((float2)float_values[i]);
    compare_char_elements("convert_char2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rtn((float2)sat_input);
    compare_char_elements("convert_char2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (CHAR_MIN > -FLT_MAX) ? (float)CHAR_MIN : -FLT_MAX;
    const float max_expected = (CHAR_MAX < FLT_MAX) ? (float)CHAR_MAX : FLT_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)float_rounded_values[i]));
    actual.value = convert_char4((float4)float_values[i]);
    compare_char_elements("convert_char4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((float4)sat_input);
    compare_char_elements("convert_char4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)float_rounded_values_rte[i]));
    actual.value = convert_char4_rte((float4)float_values[i]);
    compare_char_elements("convert_char4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rte((float4)sat_input);
    compare_char_elements("convert_char4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)float_rounded_values_rtz[i]));
    actual.value = convert_char4_rtz((float4)float_values[i]);
    compare_char_elements("convert_char4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rtz((float4)sat_input);
    compare_char_elements("convert_char4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)float_rounded_values_rtp[i]));
    actual.value = convert_char4_rtp((float4)float_values[i]);
    compare_char_elements("convert_char4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rtp((float4)sat_input);
    compare_char_elements("convert_char4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)float_rounded_values_rtn[i]));
    actual.value = convert_char4_rtn((float4)float_values[i]);
    compare_char_elements("convert_char4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rtn((float4)sat_input);
    compare_char_elements("convert_char4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (CHAR_MIN > -FLT_MAX) ? (float)CHAR_MIN : -FLT_MAX;
    const float max_expected = (CHAR_MAX < FLT_MAX) ? (float)CHAR_MAX : FLT_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)float_rounded_values[i]));
    actual.value = convert_char8((float8)float_values[i]);
    compare_char_elements("convert_char8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((float8)sat_input);
    compare_char_elements("convert_char8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)float_rounded_values_rte[i]));
    actual.value = convert_char8_rte((float8)float_values[i]);
    compare_char_elements("convert_char8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rte((float8)sat_input);
    compare_char_elements("convert_char8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)float_rounded_values_rtz[i]));
    actual.value = convert_char8_rtz((float8)float_values[i]);
    compare_char_elements("convert_char8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rtz((float8)sat_input);
    compare_char_elements("convert_char8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)float_rounded_values_rtp[i]));
    actual.value = convert_char8_rtp((float8)float_values[i]);
    compare_char_elements("convert_char8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rtp((float8)sat_input);
    compare_char_elements("convert_char8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)float_rounded_values_rtn[i]));
    actual.value = convert_char8_rtn((float8)float_values[i]);
    compare_char_elements("convert_char8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rtn((float8)sat_input);
    compare_char_elements("convert_char8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (CHAR_MIN > -FLT_MAX) ? (float)CHAR_MIN : -FLT_MAX;
    const float max_expected = (CHAR_MAX < FLT_MAX) ? (float)CHAR_MAX : FLT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)float_rounded_values[i]));
    actual.value = convert_char16((float16)float_values[i]);
    compare_char_elements("convert_char16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((float16)sat_input);
    compare_char_elements("convert_char16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rte[i]));
    actual.value = convert_char16_rte((float16)float_values[i]);
    compare_char_elements("convert_char16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rte((float16)sat_input);
    compare_char_elements("convert_char16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rtz[i]));
    actual.value = convert_char16_rtz((float16)float_values[i]);
    compare_char_elements("convert_char16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtz((float16)sat_input);
    compare_char_elements("convert_char16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rtp[i]));
    actual.value = convert_char16_rtp((float16)float_values[i]);
    compare_char_elements("convert_char16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtp((float16)sat_input);
    compare_char_elements("convert_char16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rtn[i]));
    actual.value = convert_char16_rtn((float16)float_values[i]);
    compare_char_elements("convert_char16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtn((float16)sat_input);
    compare_char_elements("convert_char16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UCHAR_MAX < FLT_MAX) ? (float)UCHAR_MAX : FLT_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)float_rounded_values[i]));
    actual.value = convert_uchar((float)float_values[i]);
    compare_uchar_elements("convert_uchar((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((float)sat_input);
    compare_uchar_elements("convert_uchar_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)float_rounded_values_rte[i]));
    actual.value = convert_uchar_rte((float)float_values[i]);
    compare_uchar_elements("convert_uchar_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rte((float)sat_input);
    compare_uchar_elements("convert_uchar_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)float_rounded_values_rtz[i]));
    actual.value = convert_uchar_rtz((float)float_values[i]);
    compare_uchar_elements("convert_uchar_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rtz((float)sat_input);
    compare_uchar_elements("convert_uchar_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)float_rounded_values_rtp[i]));
    actual.value = convert_uchar_rtp((float)float_values[i]);
    compare_uchar_elements("convert_uchar_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rtp((float)sat_input);
    compare_uchar_elements("convert_uchar_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)float_rounded_values_rtn[i]));
    actual.value = convert_uchar_rtn((float)float_values[i]);
    compare_uchar_elements("convert_uchar_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rtn((float)sat_input);
    compare_uchar_elements("convert_uchar_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UCHAR_MAX < FLT_MAX) ? (float)UCHAR_MAX : FLT_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)float_rounded_values[i]));
    actual.value = convert_uchar2((float2)float_values[i]);
    compare_uchar_elements("convert_uchar2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((float2)sat_input);
    compare_uchar_elements("convert_uchar2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)float_rounded_values_rte[i]));
    actual.value = convert_uchar2_rte((float2)float_values[i]);
    compare_uchar_elements("convert_uchar2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rte((float2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)float_rounded_values_rtz[i]));
    actual.value = convert_uchar2_rtz((float2)float_values[i]);
    compare_uchar_elements("convert_uchar2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rtz((float2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)float_rounded_values_rtp[i]));
    actual.value = convert_uchar2_rtp((float2)float_values[i]);
    compare_uchar_elements("convert_uchar2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rtp((float2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)float_rounded_values_rtn[i]));
    actual.value = convert_uchar2_rtn((float2)float_values[i]);
    compare_uchar_elements("convert_uchar2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rtn((float2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UCHAR_MAX < FLT_MAX) ? (float)UCHAR_MAX : FLT_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)float_rounded_values[i]));
    actual.value = convert_uchar4((float4)float_values[i]);
    compare_uchar_elements("convert_uchar4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((float4)sat_input);
    compare_uchar_elements("convert_uchar4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)float_rounded_values_rte[i]));
    actual.value = convert_uchar4_rte((float4)float_values[i]);
    compare_uchar_elements("convert_uchar4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rte((float4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)float_rounded_values_rtz[i]));
    actual.value = convert_uchar4_rtz((float4)float_values[i]);
    compare_uchar_elements("convert_uchar4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rtz((float4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)float_rounded_values_rtp[i]));
    actual.value = convert_uchar4_rtp((float4)float_values[i]);
    compare_uchar_elements("convert_uchar4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rtp((float4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)float_rounded_values_rtn[i]));
    actual.value = convert_uchar4_rtn((float4)float_values[i]);
    compare_uchar_elements("convert_uchar4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rtn((float4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UCHAR_MAX < FLT_MAX) ? (float)UCHAR_MAX : FLT_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)float_rounded_values[i]));
    actual.value = convert_uchar8((float8)float_values[i]);
    compare_uchar_elements("convert_uchar8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((float8)sat_input);
    compare_uchar_elements("convert_uchar8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)float_rounded_values_rte[i]));
    actual.value = convert_uchar8_rte((float8)float_values[i]);
    compare_uchar_elements("convert_uchar8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rte((float8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)float_rounded_values_rtz[i]));
    actual.value = convert_uchar8_rtz((float8)float_values[i]);
    compare_uchar_elements("convert_uchar8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rtz((float8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)float_rounded_values_rtp[i]));
    actual.value = convert_uchar8_rtp((float8)float_values[i]);
    compare_uchar_elements("convert_uchar8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rtp((float8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)float_rounded_values_rtn[i]));
    actual.value = convert_uchar8_rtn((float8)float_values[i]);
    compare_uchar_elements("convert_uchar8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rtn((float8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UCHAR_MAX < FLT_MAX) ? (float)UCHAR_MAX : FLT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)float_rounded_values[i]));
    actual.value = convert_uchar16((float16)float_values[i]);
    compare_uchar_elements("convert_uchar16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((float16)sat_input);
    compare_uchar_elements("convert_uchar16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rte[i]));
    actual.value = convert_uchar16_rte((float16)float_values[i]);
    compare_uchar_elements("convert_uchar16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rte((float16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rtz[i]));
    actual.value = convert_uchar16_rtz((float16)float_values[i]);
    compare_uchar_elements("convert_uchar16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtz((float16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rtp[i]));
    actual.value = convert_uchar16_rtp((float16)float_values[i]);
    compare_uchar_elements("convert_uchar16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtp((float16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rtn[i]));
    actual.value = convert_uchar16_rtn((float16)float_values[i]);
    compare_uchar_elements("convert_uchar16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtn((float16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (SHRT_MIN > -FLT_MAX) ? (float)SHRT_MIN : -FLT_MAX;
    const float max_expected = (SHRT_MAX < FLT_MAX) ? (float)SHRT_MAX : FLT_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)float_rounded_values[i]));
    actual.value = convert_short((float)float_values[i]);
    compare_short_elements("convert_short((float))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((float)sat_input);
    compare_short_elements("convert_short_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)float_rounded_values_rte[i]));
    actual.value = convert_short_rte((float)float_values[i]);
    compare_short_elements("convert_short_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rte((float)sat_input);
    compare_short_elements("convert_short_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)float_rounded_values_rtz[i]));
    actual.value = convert_short_rtz((float)float_values[i]);
    compare_short_elements("convert_short_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rtz((float)sat_input);
    compare_short_elements("convert_short_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)float_rounded_values_rtp[i]));
    actual.value = convert_short_rtp((float)float_values[i]);
    compare_short_elements("convert_short_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rtp((float)sat_input);
    compare_short_elements("convert_short_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)float_rounded_values_rtn[i]));
    actual.value = convert_short_rtn((float)float_values[i]);
    compare_short_elements("convert_short_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rtn((float)sat_input);
    compare_short_elements("convert_short_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (SHRT_MIN > -FLT_MAX) ? (float)SHRT_MIN : -FLT_MAX;
    const float max_expected = (SHRT_MAX < FLT_MAX) ? (float)SHRT_MAX : FLT_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)float_rounded_values[i]));
    actual.value = convert_short2((float2)float_values[i]);
    compare_short_elements("convert_short2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((float2)sat_input);
    compare_short_elements("convert_short2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)float_rounded_values_rte[i]));
    actual.value = convert_short2_rte((float2)float_values[i]);
    compare_short_elements("convert_short2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rte((float2)sat_input);
    compare_short_elements("convert_short2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)float_rounded_values_rtz[i]));
    actual.value = convert_short2_rtz((float2)float_values[i]);
    compare_short_elements("convert_short2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rtz((float2)sat_input);
    compare_short_elements("convert_short2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)float_rounded_values_rtp[i]));
    actual.value = convert_short2_rtp((float2)float_values[i]);
    compare_short_elements("convert_short2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rtp((float2)sat_input);
    compare_short_elements("convert_short2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)float_rounded_values_rtn[i]));
    actual.value = convert_short2_rtn((float2)float_values[i]);
    compare_short_elements("convert_short2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rtn((float2)sat_input);
    compare_short_elements("convert_short2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (SHRT_MIN > -FLT_MAX) ? (float)SHRT_MIN : -FLT_MAX;
    const float max_expected = (SHRT_MAX < FLT_MAX) ? (float)SHRT_MAX : FLT_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)float_rounded_values[i]));
    actual.value = convert_short4((float4)float_values[i]);
    compare_short_elements("convert_short4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((float4)sat_input);
    compare_short_elements("convert_short4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)float_rounded_values_rte[i]));
    actual.value = convert_short4_rte((float4)float_values[i]);
    compare_short_elements("convert_short4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rte((float4)sat_input);
    compare_short_elements("convert_short4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)float_rounded_values_rtz[i]));
    actual.value = convert_short4_rtz((float4)float_values[i]);
    compare_short_elements("convert_short4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rtz((float4)sat_input);
    compare_short_elements("convert_short4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)float_rounded_values_rtp[i]));
    actual.value = convert_short4_rtp((float4)float_values[i]);
    compare_short_elements("convert_short4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rtp((float4)sat_input);
    compare_short_elements("convert_short4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)float_rounded_values_rtn[i]));
    actual.value = convert_short4_rtn((float4)float_values[i]);
    compare_short_elements("convert_short4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rtn((float4)sat_input);
    compare_short_elements("convert_short4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (SHRT_MIN > -FLT_MAX) ? (float)SHRT_MIN : -FLT_MAX;
    const float max_expected = (SHRT_MAX < FLT_MAX) ? (float)SHRT_MAX : FLT_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)float_rounded_values[i]));
    actual.value = convert_short8((float8)float_values[i]);
    compare_short_elements("convert_short8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((float8)sat_input);
    compare_short_elements("convert_short8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)float_rounded_values_rte[i]));
    actual.value = convert_short8_rte((float8)float_values[i]);
    compare_short_elements("convert_short8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rte((float8)sat_input);
    compare_short_elements("convert_short8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)float_rounded_values_rtz[i]));
    actual.value = convert_short8_rtz((float8)float_values[i]);
    compare_short_elements("convert_short8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rtz((float8)sat_input);
    compare_short_elements("convert_short8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)float_rounded_values_rtp[i]));
    actual.value = convert_short8_rtp((float8)float_values[i]);
    compare_short_elements("convert_short8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rtp((float8)sat_input);
    compare_short_elements("convert_short8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)float_rounded_values_rtn[i]));
    actual.value = convert_short8_rtn((float8)float_values[i]);
    compare_short_elements("convert_short8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rtn((float8)sat_input);
    compare_short_elements("convert_short8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (SHRT_MIN > -FLT_MAX) ? (float)SHRT_MIN : -FLT_MAX;
    const float max_expected = (SHRT_MAX < FLT_MAX) ? (float)SHRT_MAX : FLT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)float_rounded_values[i]));
    actual.value = convert_short16((float16)float_values[i]);
    compare_short_elements("convert_short16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((float16)sat_input);
    compare_short_elements("convert_short16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rte[i]));
    actual.value = convert_short16_rte((float16)float_values[i]);
    compare_short_elements("convert_short16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rte((float16)sat_input);
    compare_short_elements("convert_short16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rtz[i]));
    actual.value = convert_short16_rtz((float16)float_values[i]);
    compare_short_elements("convert_short16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtz((float16)sat_input);
    compare_short_elements("convert_short16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rtp[i]));
    actual.value = convert_short16_rtp((float16)float_values[i]);
    compare_short_elements("convert_short16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtp((float16)sat_input);
    compare_short_elements("convert_short16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rtn[i]));
    actual.value = convert_short16_rtn((float16)float_values[i]);
    compare_short_elements("convert_short16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtn((float16)sat_input);
    compare_short_elements("convert_short16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (USHRT_MAX < FLT_MAX) ? (float)USHRT_MAX : FLT_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)float_rounded_values[i]));
    actual.value = convert_ushort((float)float_values[i]);
    compare_ushort_elements("convert_ushort((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((float)sat_input);
    compare_ushort_elements("convert_ushort_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)float_rounded_values_rte[i]));
    actual.value = convert_ushort_rte((float)float_values[i]);
    compare_ushort_elements("convert_ushort_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rte((float)sat_input);
    compare_ushort_elements("convert_ushort_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)float_rounded_values_rtz[i]));
    actual.value = convert_ushort_rtz((float)float_values[i]);
    compare_ushort_elements("convert_ushort_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rtz((float)sat_input);
    compare_ushort_elements("convert_ushort_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)float_rounded_values_rtp[i]));
    actual.value = convert_ushort_rtp((float)float_values[i]);
    compare_ushort_elements("convert_ushort_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rtp((float)sat_input);
    compare_ushort_elements("convert_ushort_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)float_rounded_values_rtn[i]));
    actual.value = convert_ushort_rtn((float)float_values[i]);
    compare_ushort_elements("convert_ushort_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rtn((float)sat_input);
    compare_ushort_elements("convert_ushort_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (USHRT_MAX < FLT_MAX) ? (float)USHRT_MAX : FLT_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)float_rounded_values[i]));
    actual.value = convert_ushort2((float2)float_values[i]);
    compare_ushort_elements("convert_ushort2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((float2)sat_input);
    compare_ushort_elements("convert_ushort2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)float_rounded_values_rte[i]));
    actual.value = convert_ushort2_rte((float2)float_values[i]);
    compare_ushort_elements("convert_ushort2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rte((float2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)float_rounded_values_rtz[i]));
    actual.value = convert_ushort2_rtz((float2)float_values[i]);
    compare_ushort_elements("convert_ushort2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rtz((float2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)float_rounded_values_rtp[i]));
    actual.value = convert_ushort2_rtp((float2)float_values[i]);
    compare_ushort_elements("convert_ushort2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rtp((float2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)float_rounded_values_rtn[i]));
    actual.value = convert_ushort2_rtn((float2)float_values[i]);
    compare_ushort_elements("convert_ushort2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rtn((float2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (USHRT_MAX < FLT_MAX) ? (float)USHRT_MAX : FLT_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)float_rounded_values[i]));
    actual.value = convert_ushort4((float4)float_values[i]);
    compare_ushort_elements("convert_ushort4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((float4)sat_input);
    compare_ushort_elements("convert_ushort4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)float_rounded_values_rte[i]));
    actual.value = convert_ushort4_rte((float4)float_values[i]);
    compare_ushort_elements("convert_ushort4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rte((float4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)float_rounded_values_rtz[i]));
    actual.value = convert_ushort4_rtz((float4)float_values[i]);
    compare_ushort_elements("convert_ushort4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rtz((float4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)float_rounded_values_rtp[i]));
    actual.value = convert_ushort4_rtp((float4)float_values[i]);
    compare_ushort_elements("convert_ushort4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rtp((float4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)float_rounded_values_rtn[i]));
    actual.value = convert_ushort4_rtn((float4)float_values[i]);
    compare_ushort_elements("convert_ushort4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rtn((float4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (USHRT_MAX < FLT_MAX) ? (float)USHRT_MAX : FLT_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)float_rounded_values[i]));
    actual.value = convert_ushort8((float8)float_values[i]);
    compare_ushort_elements("convert_ushort8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((float8)sat_input);
    compare_ushort_elements("convert_ushort8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)float_rounded_values_rte[i]));
    actual.value = convert_ushort8_rte((float8)float_values[i]);
    compare_ushort_elements("convert_ushort8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rte((float8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)float_rounded_values_rtz[i]));
    actual.value = convert_ushort8_rtz((float8)float_values[i]);
    compare_ushort_elements("convert_ushort8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rtz((float8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)float_rounded_values_rtp[i]));
    actual.value = convert_ushort8_rtp((float8)float_values[i]);
    compare_ushort_elements("convert_ushort8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rtp((float8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)float_rounded_values_rtn[i]));
    actual.value = convert_ushort8_rtn((float8)float_values[i]);
    compare_ushort_elements("convert_ushort8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rtn((float8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (USHRT_MAX < FLT_MAX) ? (float)USHRT_MAX : FLT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)float_rounded_values[i]));
    actual.value = convert_ushort16((float16)float_values[i]);
    compare_ushort_elements("convert_ushort16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((float16)sat_input);
    compare_ushort_elements("convert_ushort16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rte[i]));
    actual.value = convert_ushort16_rte((float16)float_values[i]);
    compare_ushort_elements("convert_ushort16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rte((float16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rtz[i]));
    actual.value = convert_ushort16_rtz((float16)float_values[i]);
    compare_ushort_elements("convert_ushort16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtz((float16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rtp[i]));
    actual.value = convert_ushort16_rtp((float16)float_values[i]);
    compare_ushort_elements("convert_ushort16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtp((float16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rtn[i]));
    actual.value = convert_ushort16_rtn((float16)float_values[i]);
    compare_ushort_elements("convert_ushort16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtn((float16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (INT_MIN > -FLT_MAX) ? (float)INT_MIN : -FLT_MAX;
    const float max_expected = (INT_MAX < FLT_MAX) ? (float)INT_MAX : FLT_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)float_rounded_values[i]));
    actual.value = convert_int((float)float_values[i]);
    compare_int_elements("convert_int((float))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((float)sat_input);
    compare_int_elements("convert_int_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)float_rounded_values_rte[i]));
    actual.value = convert_int_rte((float)float_values[i]);
    compare_int_elements("convert_int_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rte((float)sat_input);
    compare_int_elements("convert_int_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)float_rounded_values_rtz[i]));
    actual.value = convert_int_rtz((float)float_values[i]);
    compare_int_elements("convert_int_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rtz((float)sat_input);
    compare_int_elements("convert_int_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)float_rounded_values_rtp[i]));
    actual.value = convert_int_rtp((float)float_values[i]);
    compare_int_elements("convert_int_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rtp((float)sat_input);
    compare_int_elements("convert_int_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)float_rounded_values_rtn[i]));
    actual.value = convert_int_rtn((float)float_values[i]);
    compare_int_elements("convert_int_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rtn((float)sat_input);
    compare_int_elements("convert_int_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (INT_MIN > -FLT_MAX) ? (float)INT_MIN : -FLT_MAX;
    const float max_expected = (INT_MAX < FLT_MAX) ? (float)INT_MAX : FLT_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)float_rounded_values[i]));
    actual.value = convert_int2((float2)float_values[i]);
    compare_int_elements("convert_int2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((float2)sat_input);
    compare_int_elements("convert_int2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)float_rounded_values_rte[i]));
    actual.value = convert_int2_rte((float2)float_values[i]);
    compare_int_elements("convert_int2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rte((float2)sat_input);
    compare_int_elements("convert_int2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)float_rounded_values_rtz[i]));
    actual.value = convert_int2_rtz((float2)float_values[i]);
    compare_int_elements("convert_int2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rtz((float2)sat_input);
    compare_int_elements("convert_int2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)float_rounded_values_rtp[i]));
    actual.value = convert_int2_rtp((float2)float_values[i]);
    compare_int_elements("convert_int2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rtp((float2)sat_input);
    compare_int_elements("convert_int2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)float_rounded_values_rtn[i]));
    actual.value = convert_int2_rtn((float2)float_values[i]);
    compare_int_elements("convert_int2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rtn((float2)sat_input);
    compare_int_elements("convert_int2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (INT_MIN > -FLT_MAX) ? (float)INT_MIN : -FLT_MAX;
    const float max_expected = (INT_MAX < FLT_MAX) ? (float)INT_MAX : FLT_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)float_rounded_values[i]));
    actual.value = convert_int4((float4)float_values[i]);
    compare_int_elements("convert_int4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((float4)sat_input);
    compare_int_elements("convert_int4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)float_rounded_values_rte[i]));
    actual.value = convert_int4_rte((float4)float_values[i]);
    compare_int_elements("convert_int4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rte((float4)sat_input);
    compare_int_elements("convert_int4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)float_rounded_values_rtz[i]));
    actual.value = convert_int4_rtz((float4)float_values[i]);
    compare_int_elements("convert_int4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rtz((float4)sat_input);
    compare_int_elements("convert_int4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)float_rounded_values_rtp[i]));
    actual.value = convert_int4_rtp((float4)float_values[i]);
    compare_int_elements("convert_int4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rtp((float4)sat_input);
    compare_int_elements("convert_int4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)float_rounded_values_rtn[i]));
    actual.value = convert_int4_rtn((float4)float_values[i]);
    compare_int_elements("convert_int4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rtn((float4)sat_input);
    compare_int_elements("convert_int4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (INT_MIN > -FLT_MAX) ? (float)INT_MIN : -FLT_MAX;
    const float max_expected = (INT_MAX < FLT_MAX) ? (float)INT_MAX : FLT_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)float_rounded_values[i]));
    actual.value = convert_int8((float8)float_values[i]);
    compare_int_elements("convert_int8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((float8)sat_input);
    compare_int_elements("convert_int8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)float_rounded_values_rte[i]));
    actual.value = convert_int8_rte((float8)float_values[i]);
    compare_int_elements("convert_int8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rte((float8)sat_input);
    compare_int_elements("convert_int8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)float_rounded_values_rtz[i]));
    actual.value = convert_int8_rtz((float8)float_values[i]);
    compare_int_elements("convert_int8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rtz((float8)sat_input);
    compare_int_elements("convert_int8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)float_rounded_values_rtp[i]));
    actual.value = convert_int8_rtp((float8)float_values[i]);
    compare_int_elements("convert_int8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rtp((float8)sat_input);
    compare_int_elements("convert_int8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)float_rounded_values_rtn[i]));
    actual.value = convert_int8_rtn((float8)float_values[i]);
    compare_int_elements("convert_int8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rtn((float8)sat_input);
    compare_int_elements("convert_int8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (INT_MIN > -FLT_MAX) ? (float)INT_MIN : -FLT_MAX;
    const float max_expected = (INT_MAX < FLT_MAX) ? (float)INT_MAX : FLT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)float_rounded_values[i]));
    actual.value = convert_int16((float16)float_values[i]);
    compare_int_elements("convert_int16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((float16)sat_input);
    compare_int_elements("convert_int16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rte[i]));
    actual.value = convert_int16_rte((float16)float_values[i]);
    compare_int_elements("convert_int16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rte((float16)sat_input);
    compare_int_elements("convert_int16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rtz[i]));
    actual.value = convert_int16_rtz((float16)float_values[i]);
    compare_int_elements("convert_int16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtz((float16)sat_input);
    compare_int_elements("convert_int16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rtp[i]));
    actual.value = convert_int16_rtp((float16)float_values[i]);
    compare_int_elements("convert_int16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtp((float16)sat_input);
    compare_int_elements("convert_int16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rtn[i]));
    actual.value = convert_int16_rtn((float16)float_values[i]);
    compare_int_elements("convert_int16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtn((float16)sat_input);
    compare_int_elements("convert_int16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UINT_MAX < FLT_MAX) ? (float)UINT_MAX : FLT_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)float_rounded_values[i]));
    actual.value = convert_uint((float)float_values[i]);
    compare_uint_elements("convert_uint((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((float)sat_input);
    compare_uint_elements("convert_uint_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)float_rounded_values_rte[i]));
    actual.value = convert_uint_rte((float)float_values[i]);
    compare_uint_elements("convert_uint_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rte((float)sat_input);
    compare_uint_elements("convert_uint_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)float_rounded_values_rtz[i]));
    actual.value = convert_uint_rtz((float)float_values[i]);
    compare_uint_elements("convert_uint_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rtz((float)sat_input);
    compare_uint_elements("convert_uint_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)float_rounded_values_rtp[i]));
    actual.value = convert_uint_rtp((float)float_values[i]);
    compare_uint_elements("convert_uint_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rtp((float)sat_input);
    compare_uint_elements("convert_uint_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)float_rounded_values_rtn[i]));
    actual.value = convert_uint_rtn((float)float_values[i]);
    compare_uint_elements("convert_uint_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rtn((float)sat_input);
    compare_uint_elements("convert_uint_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UINT_MAX < FLT_MAX) ? (float)UINT_MAX : FLT_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)float_rounded_values[i]));
    actual.value = convert_uint2((float2)float_values[i]);
    compare_uint_elements("convert_uint2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((float2)sat_input);
    compare_uint_elements("convert_uint2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)float_rounded_values_rte[i]));
    actual.value = convert_uint2_rte((float2)float_values[i]);
    compare_uint_elements("convert_uint2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rte((float2)sat_input);
    compare_uint_elements("convert_uint2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)float_rounded_values_rtz[i]));
    actual.value = convert_uint2_rtz((float2)float_values[i]);
    compare_uint_elements("convert_uint2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rtz((float2)sat_input);
    compare_uint_elements("convert_uint2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)float_rounded_values_rtp[i]));
    actual.value = convert_uint2_rtp((float2)float_values[i]);
    compare_uint_elements("convert_uint2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rtp((float2)sat_input);
    compare_uint_elements("convert_uint2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)float_rounded_values_rtn[i]));
    actual.value = convert_uint2_rtn((float2)float_values[i]);
    compare_uint_elements("convert_uint2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rtn((float2)sat_input);
    compare_uint_elements("convert_uint2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UINT_MAX < FLT_MAX) ? (float)UINT_MAX : FLT_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)float_rounded_values[i]));
    actual.value = convert_uint4((float4)float_values[i]);
    compare_uint_elements("convert_uint4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((float4)sat_input);
    compare_uint_elements("convert_uint4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)float_rounded_values_rte[i]));
    actual.value = convert_uint4_rte((float4)float_values[i]);
    compare_uint_elements("convert_uint4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rte((float4)sat_input);
    compare_uint_elements("convert_uint4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)float_rounded_values_rtz[i]));
    actual.value = convert_uint4_rtz((float4)float_values[i]);
    compare_uint_elements("convert_uint4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rtz((float4)sat_input);
    compare_uint_elements("convert_uint4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)float_rounded_values_rtp[i]));
    actual.value = convert_uint4_rtp((float4)float_values[i]);
    compare_uint_elements("convert_uint4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rtp((float4)sat_input);
    compare_uint_elements("convert_uint4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)float_rounded_values_rtn[i]));
    actual.value = convert_uint4_rtn((float4)float_values[i]);
    compare_uint_elements("convert_uint4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rtn((float4)sat_input);
    compare_uint_elements("convert_uint4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UINT_MAX < FLT_MAX) ? (float)UINT_MAX : FLT_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)float_rounded_values[i]));
    actual.value = convert_uint8((float8)float_values[i]);
    compare_uint_elements("convert_uint8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((float8)sat_input);
    compare_uint_elements("convert_uint8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)float_rounded_values_rte[i]));
    actual.value = convert_uint8_rte((float8)float_values[i]);
    compare_uint_elements("convert_uint8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rte((float8)sat_input);
    compare_uint_elements("convert_uint8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)float_rounded_values_rtz[i]));
    actual.value = convert_uint8_rtz((float8)float_values[i]);
    compare_uint_elements("convert_uint8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rtz((float8)sat_input);
    compare_uint_elements("convert_uint8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)float_rounded_values_rtp[i]));
    actual.value = convert_uint8_rtp((float8)float_values[i]);
    compare_uint_elements("convert_uint8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rtp((float8)sat_input);
    compare_uint_elements("convert_uint8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)float_rounded_values_rtn[i]));
    actual.value = convert_uint8_rtn((float8)float_values[i]);
    compare_uint_elements("convert_uint8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rtn((float8)sat_input);
    compare_uint_elements("convert_uint8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (UINT_MAX < FLT_MAX) ? (float)UINT_MAX : FLT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)float_rounded_values[i]));
    actual.value = convert_uint16((float16)float_values[i]);
    compare_uint_elements("convert_uint16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((float16)sat_input);
    compare_uint_elements("convert_uint16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rte[i]));
    actual.value = convert_uint16_rte((float16)float_values[i]);
    compare_uint_elements("convert_uint16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rte((float16)sat_input);
    compare_uint_elements("convert_uint16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rtz[i]));
    actual.value = convert_uint16_rtz((float16)float_values[i]);
    compare_uint_elements("convert_uint16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtz((float16)sat_input);
    compare_uint_elements("convert_uint16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rtp[i]));
    actual.value = convert_uint16_rtp((float16)float_values[i]);
    compare_uint_elements("convert_uint16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtp((float16)sat_input);
    compare_uint_elements("convert_uint16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rtn[i]));
    actual.value = convert_uint16_rtn((float16)float_values[i]);
    compare_uint_elements("convert_uint16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtn((float16)sat_input);
    compare_uint_elements("convert_uint16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (LONG_MIN > -FLT_MAX) ? (float)LONG_MIN : -FLT_MAX;
    const float max_expected = (LONG_MAX < FLT_MAX) ? (float)LONG_MAX : FLT_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)float_rounded_values[i]));
    actual.value = convert_long((float)float_values[i]);
    compare_long_elements("convert_long((float))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((float)sat_input);
    compare_long_elements("convert_long_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)float_rounded_values_rte[i]));
    actual.value = convert_long_rte((float)float_values[i]);
    compare_long_elements("convert_long_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rte((float)sat_input);
    compare_long_elements("convert_long_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)float_rounded_values_rtz[i]));
    actual.value = convert_long_rtz((float)float_values[i]);
    compare_long_elements("convert_long_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rtz((float)sat_input);
    compare_long_elements("convert_long_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)float_rounded_values_rtp[i]));
    actual.value = convert_long_rtp((float)float_values[i]);
    compare_long_elements("convert_long_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rtp((float)sat_input);
    compare_long_elements("convert_long_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)float_rounded_values_rtn[i]));
    actual.value = convert_long_rtn((float)float_values[i]);
    compare_long_elements("convert_long_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rtn((float)sat_input);
    compare_long_elements("convert_long_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (LONG_MIN > -FLT_MAX) ? (float)LONG_MIN : -FLT_MAX;
    const float max_expected = (LONG_MAX < FLT_MAX) ? (float)LONG_MAX : FLT_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)float_rounded_values[i]));
    actual.value = convert_long2((float2)float_values[i]);
    compare_long_elements("convert_long2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((float2)sat_input);
    compare_long_elements("convert_long2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)float_rounded_values_rte[i]));
    actual.value = convert_long2_rte((float2)float_values[i]);
    compare_long_elements("convert_long2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rte((float2)sat_input);
    compare_long_elements("convert_long2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)float_rounded_values_rtz[i]));
    actual.value = convert_long2_rtz((float2)float_values[i]);
    compare_long_elements("convert_long2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rtz((float2)sat_input);
    compare_long_elements("convert_long2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)float_rounded_values_rtp[i]));
    actual.value = convert_long2_rtp((float2)float_values[i]);
    compare_long_elements("convert_long2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rtp((float2)sat_input);
    compare_long_elements("convert_long2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)float_rounded_values_rtn[i]));
    actual.value = convert_long2_rtn((float2)float_values[i]);
    compare_long_elements("convert_long2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rtn((float2)sat_input);
    compare_long_elements("convert_long2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (LONG_MIN > -FLT_MAX) ? (float)LONG_MIN : -FLT_MAX;
    const float max_expected = (LONG_MAX < FLT_MAX) ? (float)LONG_MAX : FLT_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)float_rounded_values[i]));
    actual.value = convert_long4((float4)float_values[i]);
    compare_long_elements("convert_long4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((float4)sat_input);
    compare_long_elements("convert_long4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)float_rounded_values_rte[i]));
    actual.value = convert_long4_rte((float4)float_values[i]);
    compare_long_elements("convert_long4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rte((float4)sat_input);
    compare_long_elements("convert_long4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)float_rounded_values_rtz[i]));
    actual.value = convert_long4_rtz((float4)float_values[i]);
    compare_long_elements("convert_long4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rtz((float4)sat_input);
    compare_long_elements("convert_long4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)float_rounded_values_rtp[i]));
    actual.value = convert_long4_rtp((float4)float_values[i]);
    compare_long_elements("convert_long4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rtp((float4)sat_input);
    compare_long_elements("convert_long4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)float_rounded_values_rtn[i]));
    actual.value = convert_long4_rtn((float4)float_values[i]);
    compare_long_elements("convert_long4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rtn((float4)sat_input);
    compare_long_elements("convert_long4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (LONG_MIN > -FLT_MAX) ? (float)LONG_MIN : -FLT_MAX;
    const float max_expected = (LONG_MAX < FLT_MAX) ? (float)LONG_MAX : FLT_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)float_rounded_values[i]));
    actual.value = convert_long8((float8)float_values[i]);
    compare_long_elements("convert_long8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((float8)sat_input);
    compare_long_elements("convert_long8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)float_rounded_values_rte[i]));
    actual.value = convert_long8_rte((float8)float_values[i]);
    compare_long_elements("convert_long8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rte((float8)sat_input);
    compare_long_elements("convert_long8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)float_rounded_values_rtz[i]));
    actual.value = convert_long8_rtz((float8)float_values[i]);
    compare_long_elements("convert_long8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rtz((float8)sat_input);
    compare_long_elements("convert_long8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)float_rounded_values_rtp[i]));
    actual.value = convert_long8_rtp((float8)float_values[i]);
    compare_long_elements("convert_long8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rtp((float8)sat_input);
    compare_long_elements("convert_long8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)float_rounded_values_rtn[i]));
    actual.value = convert_long8_rtn((float8)float_values[i]);
    compare_long_elements("convert_long8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rtn((float8)sat_input);
    compare_long_elements("convert_long8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (LONG_MIN > -FLT_MAX) ? (float)LONG_MIN : -FLT_MAX;
    const float max_expected = (LONG_MAX < FLT_MAX) ? (float)LONG_MAX : FLT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)float_rounded_values[i]));
    actual.value = convert_long16((float16)float_values[i]);
    compare_long_elements("convert_long16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((float16)sat_input);
    compare_long_elements("convert_long16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rte[i]));
    actual.value = convert_long16_rte((float16)float_values[i]);
    compare_long_elements("convert_long16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rte((float16)sat_input);
    compare_long_elements("convert_long16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rtz[i]));
    actual.value = convert_long16_rtz((float16)float_values[i]);
    compare_long_elements("convert_long16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtz((float16)sat_input);
    compare_long_elements("convert_long16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rtp[i]));
    actual.value = convert_long16_rtp((float16)float_values[i]);
    compare_long_elements("convert_long16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtp((float16)sat_input);
    compare_long_elements("convert_long16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rtn[i]));
    actual.value = convert_long16_rtn((float16)float_values[i]);
    compare_long_elements("convert_long16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtn((float16)sat_input);
    compare_long_elements("convert_long16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (ULONG_MAX < FLT_MAX) ? (float)ULONG_MAX : FLT_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)float_rounded_values[i]));
    actual.value = convert_ulong((float)float_values[i]);
    compare_ulong_elements("convert_ulong((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((float)sat_input);
    compare_ulong_elements("convert_ulong_sat((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)float_rounded_values_rte[i]));
    actual.value = convert_ulong_rte((float)float_values[i]);
    compare_ulong_elements("convert_ulong_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rte((float)sat_input);
    compare_ulong_elements("convert_ulong_sat_rte((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)float_rounded_values_rtz[i]));
    actual.value = convert_ulong_rtz((float)float_values[i]);
    compare_ulong_elements("convert_ulong_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rtz((float)sat_input);
    compare_ulong_elements("convert_ulong_sat_rtz((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)float_rounded_values_rtp[i]));
    actual.value = convert_ulong_rtp((float)float_values[i]);
    compare_ulong_elements("convert_ulong_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rtp((float)sat_input);
    compare_ulong_elements("convert_ulong_sat_rtp((float))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)float_rounded_values_rtn[i]));
    actual.value = convert_ulong_rtn((float)float_values[i]);
    compare_ulong_elements("convert_ulong_rtn((float))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rtn((float)sat_input);
    compare_ulong_elements("convert_ulong_sat_rtn((float))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (ULONG_MAX < FLT_MAX) ? (float)ULONG_MAX : FLT_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)float_rounded_values[i]));
    actual.value = convert_ulong2((float2)float_values[i]);
    compare_ulong_elements("convert_ulong2((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((float2)sat_input);
    compare_ulong_elements("convert_ulong2_sat((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)float_rounded_values_rte[i]));
    actual.value = convert_ulong2_rte((float2)float_values[i]);
    compare_ulong_elements("convert_ulong2_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rte((float2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rte((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)float_rounded_values_rtz[i]));
    actual.value = convert_ulong2_rtz((float2)float_values[i]);
    compare_ulong_elements("convert_ulong2_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rtz((float2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rtz((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)float_rounded_values_rtp[i]));
    actual.value = convert_ulong2_rtp((float2)float_values[i]);
    compare_ulong_elements("convert_ulong2_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rtp((float2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rtp((float2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)float_rounded_values_rtn[i]));
    actual.value = convert_ulong2_rtn((float2)float_values[i]);
    compare_ulong_elements("convert_ulong2_rtn((float2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rtn((float2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rtn((float2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (ULONG_MAX < FLT_MAX) ? (float)ULONG_MAX : FLT_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)float_rounded_values[i]));
    actual.value = convert_ulong4((float4)float_values[i]);
    compare_ulong_elements("convert_ulong4((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((float4)sat_input);
    compare_ulong_elements("convert_ulong4_sat((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)float_rounded_values_rte[i]));
    actual.value = convert_ulong4_rte((float4)float_values[i]);
    compare_ulong_elements("convert_ulong4_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rte((float4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rte((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)float_rounded_values_rtz[i]));
    actual.value = convert_ulong4_rtz((float4)float_values[i]);
    compare_ulong_elements("convert_ulong4_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rtz((float4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rtz((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)float_rounded_values_rtp[i]));
    actual.value = convert_ulong4_rtp((float4)float_values[i]);
    compare_ulong_elements("convert_ulong4_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rtp((float4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rtp((float4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)float_rounded_values_rtn[i]));
    actual.value = convert_ulong4_rtn((float4)float_values[i]);
    compare_ulong_elements("convert_ulong4_rtn((float4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rtn((float4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rtn((float4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (ULONG_MAX < FLT_MAX) ? (float)ULONG_MAX : FLT_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)float_rounded_values[i]));
    actual.value = convert_ulong8((float8)float_values[i]);
    compare_ulong_elements("convert_ulong8((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((float8)sat_input);
    compare_ulong_elements("convert_ulong8_sat((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)float_rounded_values_rte[i]));
    actual.value = convert_ulong8_rte((float8)float_values[i]);
    compare_ulong_elements("convert_ulong8_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rte((float8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rte((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)float_rounded_values_rtz[i]));
    actual.value = convert_ulong8_rtz((float8)float_values[i]);
    compare_ulong_elements("convert_ulong8_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rtz((float8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rtz((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)float_rounded_values_rtp[i]));
    actual.value = convert_ulong8_rtp((float8)float_values[i]);
    compare_ulong_elements("convert_ulong8_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rtp((float8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rtp((float8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)float_rounded_values_rtn[i]));
    actual.value = convert_ulong8_rtn((float8)float_values[i]);
    compare_ulong_elements("convert_ulong8_rtn((float8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rtn((float8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rtn((float8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cles_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    const float min_expected = (0 > -FLT_MAX) ? (float)0 : -FLT_MAX;
    const float max_expected = (ULONG_MAX < FLT_MAX) ? (float)ULONG_MAX : FLT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)float_rounded_values[i]));
    actual.value = convert_ulong16((float16)float_values[i]);
    compare_ulong_elements("convert_ulong16((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((float16)sat_input);
    compare_ulong_elements("convert_ulong16_sat((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rte[i]));
    actual.value = convert_ulong16_rte((float16)float_values[i]);
    compare_ulong_elements("convert_ulong16_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rte((float16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rte((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rtz[i]));
    actual.value = convert_ulong16_rtz((float16)float_values[i]);
    compare_ulong_elements("convert_ulong16_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtz((float16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rtz((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rtp[i]));
    actual.value = convert_ulong16_rtp((float16)float_values[i]);
    compare_ulong_elements("convert_ulong16_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtp((float16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rtp((float16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rtn[i]));
    actual.value = convert_ulong16_rtn((float16)float_values[i]);
    compare_ulong_elements("convert_ulong16_rtn((float16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtn((float16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rtn((float16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (CHAR_MIN > -DBL_MAX) ? (double)CHAR_MIN : -DBL_MAX;
    const double max_expected = (CHAR_MAX < DBL_MAX) ? (double)CHAR_MAX : DBL_MAX;
    union { char value; char raw[1]; } expected, actual;
    expected.value = ((char)((char)double_rounded_values[i]));
    actual.value = convert_char((double)double_values[i]);
    compare_char_elements("convert_char((double))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat((double)sat_input);
    compare_char_elements("convert_char_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)double_rounded_values_rte[i]));
    actual.value = convert_char_rte((double)double_values[i]);
    compare_char_elements("convert_char_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rte((double)sat_input);
    compare_char_elements("convert_char_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)double_rounded_values_rtz[i]));
    actual.value = convert_char_rtz((double)double_values[i]);
    compare_char_elements("convert_char_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rtz((double)sat_input);
    compare_char_elements("convert_char_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)double_rounded_values_rtp[i]));
    actual.value = convert_char_rtp((double)double_values[i]);
    compare_char_elements("convert_char_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rtp((double)sat_input);
    compare_char_elements("convert_char_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((char)((char)double_rounded_values_rtn[i]));
    actual.value = convert_char_rtn((double)double_values[i]);
    compare_char_elements("convert_char_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (char)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char)max_expected;
    }
    actual.value = convert_char_sat_rtn((double)sat_input);
    compare_char_elements("convert_char_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (CHAR_MIN > -DBL_MAX) ? (double)CHAR_MIN : -DBL_MAX;
    const double max_expected = (CHAR_MAX < DBL_MAX) ? (double)CHAR_MAX : DBL_MAX;
    union { char2 value; char raw[2]; } expected, actual;
    expected.value = ((char2)((char)double_rounded_values[i]));
    actual.value = convert_char2((double2)double_values[i]);
    compare_char_elements("convert_char2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat((double2)sat_input);
    compare_char_elements("convert_char2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)double_rounded_values_rte[i]));
    actual.value = convert_char2_rte((double2)double_values[i]);
    compare_char_elements("convert_char2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rte((double2)sat_input);
    compare_char_elements("convert_char2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)double_rounded_values_rtz[i]));
    actual.value = convert_char2_rtz((double2)double_values[i]);
    compare_char_elements("convert_char2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rtz((double2)sat_input);
    compare_char_elements("convert_char2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)double_rounded_values_rtp[i]));
    actual.value = convert_char2_rtp((double2)double_values[i]);
    compare_char_elements("convert_char2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rtp((double2)sat_input);
    compare_char_elements("convert_char2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((char2)((char)double_rounded_values_rtn[i]));
    actual.value = convert_char2_rtn((double2)double_values[i]);
    compare_char_elements("convert_char2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (char2)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char2)max_expected;
    }
    actual.value = convert_char2_sat_rtn((double2)sat_input);
    compare_char_elements("convert_char2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (CHAR_MIN > -DBL_MAX) ? (double)CHAR_MIN : -DBL_MAX;
    const double max_expected = (CHAR_MAX < DBL_MAX) ? (double)CHAR_MAX : DBL_MAX;
    union { char4 value; char raw[4]; } expected, actual;
    expected.value = ((char4)((char)double_rounded_values[i]));
    actual.value = convert_char4((double4)double_values[i]);
    compare_char_elements("convert_char4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat((double4)sat_input);
    compare_char_elements("convert_char4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)double_rounded_values_rte[i]));
    actual.value = convert_char4_rte((double4)double_values[i]);
    compare_char_elements("convert_char4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rte((double4)sat_input);
    compare_char_elements("convert_char4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)double_rounded_values_rtz[i]));
    actual.value = convert_char4_rtz((double4)double_values[i]);
    compare_char_elements("convert_char4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rtz((double4)sat_input);
    compare_char_elements("convert_char4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)double_rounded_values_rtp[i]));
    actual.value = convert_char4_rtp((double4)double_values[i]);
    compare_char_elements("convert_char4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rtp((double4)sat_input);
    compare_char_elements("convert_char4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((char4)((char)double_rounded_values_rtn[i]));
    actual.value = convert_char4_rtn((double4)double_values[i]);
    compare_char_elements("convert_char4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (char4)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char4)max_expected;
    }
    actual.value = convert_char4_sat_rtn((double4)sat_input);
    compare_char_elements("convert_char4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (CHAR_MIN > -DBL_MAX) ? (double)CHAR_MIN : -DBL_MAX;
    const double max_expected = (CHAR_MAX < DBL_MAX) ? (double)CHAR_MAX : DBL_MAX;
    union { char8 value; char raw[8]; } expected, actual;
    expected.value = ((char8)((char)double_rounded_values[i]));
    actual.value = convert_char8((double8)double_values[i]);
    compare_char_elements("convert_char8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat((double8)sat_input);
    compare_char_elements("convert_char8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)double_rounded_values_rte[i]));
    actual.value = convert_char8_rte((double8)double_values[i]);
    compare_char_elements("convert_char8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rte((double8)sat_input);
    compare_char_elements("convert_char8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)double_rounded_values_rtz[i]));
    actual.value = convert_char8_rtz((double8)double_values[i]);
    compare_char_elements("convert_char8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rtz((double8)sat_input);
    compare_char_elements("convert_char8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)double_rounded_values_rtp[i]));
    actual.value = convert_char8_rtp((double8)double_values[i]);
    compare_char_elements("convert_char8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rtp((double8)sat_input);
    compare_char_elements("convert_char8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((char8)((char)double_rounded_values_rtn[i]));
    actual.value = convert_char8_rtn((double8)double_values[i]);
    compare_char_elements("convert_char8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (char8)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char8)max_expected;
    }
    actual.value = convert_char8_sat_rtn((double8)sat_input);
    compare_char_elements("convert_char8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (CHAR_MIN > -DBL_MAX) ? (double)CHAR_MIN : -DBL_MAX;
    const double max_expected = (CHAR_MAX < DBL_MAX) ? (double)CHAR_MAX : DBL_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)double_rounded_values[i]));
    actual.value = convert_char16((double16)double_values[i]);
    compare_char_elements("convert_char16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((double16)sat_input);
    compare_char_elements("convert_char16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rte[i]));
    actual.value = convert_char16_rte((double16)double_values[i]);
    compare_char_elements("convert_char16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rte((double16)sat_input);
    compare_char_elements("convert_char16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rtz[i]));
    actual.value = convert_char16_rtz((double16)double_values[i]);
    compare_char_elements("convert_char16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtz((double16)sat_input);
    compare_char_elements("convert_char16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rtp[i]));
    actual.value = convert_char16_rtp((double16)double_values[i]);
    compare_char_elements("convert_char16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtp((double16)sat_input);
    compare_char_elements("convert_char16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rtn[i]));
    actual.value = convert_char16_rtn((double16)double_values[i]);
    compare_char_elements("convert_char16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtn((double16)sat_input);
    compare_char_elements("convert_char16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UCHAR_MAX < DBL_MAX) ? (double)UCHAR_MAX : DBL_MAX;
    union { uchar value; uchar raw[1]; } expected, actual;
    expected.value = ((uchar)((uchar)double_rounded_values[i]));
    actual.value = convert_uchar((double)double_values[i]);
    compare_uchar_elements("convert_uchar((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat((double)sat_input);
    compare_uchar_elements("convert_uchar_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)double_rounded_values_rte[i]));
    actual.value = convert_uchar_rte((double)double_values[i]);
    compare_uchar_elements("convert_uchar_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rte((double)sat_input);
    compare_uchar_elements("convert_uchar_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)double_rounded_values_rtz[i]));
    actual.value = convert_uchar_rtz((double)double_values[i]);
    compare_uchar_elements("convert_uchar_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rtz((double)sat_input);
    compare_uchar_elements("convert_uchar_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)double_rounded_values_rtp[i]));
    actual.value = convert_uchar_rtp((double)double_values[i]);
    compare_uchar_elements("convert_uchar_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rtp((double)sat_input);
    compare_uchar_elements("convert_uchar_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uchar)((uchar)double_rounded_values_rtn[i]));
    actual.value = convert_uchar_rtn((double)double_values[i]);
    compare_uchar_elements("convert_uchar_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uchar)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar)max_expected;
    }
    actual.value = convert_uchar_sat_rtn((double)sat_input);
    compare_uchar_elements("convert_uchar_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UCHAR_MAX < DBL_MAX) ? (double)UCHAR_MAX : DBL_MAX;
    union { uchar2 value; uchar raw[2]; } expected, actual;
    expected.value = ((uchar2)((uchar)double_rounded_values[i]));
    actual.value = convert_uchar2((double2)double_values[i]);
    compare_uchar_elements("convert_uchar2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat((double2)sat_input);
    compare_uchar_elements("convert_uchar2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)double_rounded_values_rte[i]));
    actual.value = convert_uchar2_rte((double2)double_values[i]);
    compare_uchar_elements("convert_uchar2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rte((double2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)double_rounded_values_rtz[i]));
    actual.value = convert_uchar2_rtz((double2)double_values[i]);
    compare_uchar_elements("convert_uchar2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rtz((double2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)double_rounded_values_rtp[i]));
    actual.value = convert_uchar2_rtp((double2)double_values[i]);
    compare_uchar_elements("convert_uchar2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rtp((double2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uchar2)((uchar)double_rounded_values_rtn[i]));
    actual.value = convert_uchar2_rtn((double2)double_values[i]);
    compare_uchar_elements("convert_uchar2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uchar2)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar2)max_expected;
    }
    actual.value = convert_uchar2_sat_rtn((double2)sat_input);
    compare_uchar_elements("convert_uchar2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UCHAR_MAX < DBL_MAX) ? (double)UCHAR_MAX : DBL_MAX;
    union { uchar4 value; uchar raw[4]; } expected, actual;
    expected.value = ((uchar4)((uchar)double_rounded_values[i]));
    actual.value = convert_uchar4((double4)double_values[i]);
    compare_uchar_elements("convert_uchar4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat((double4)sat_input);
    compare_uchar_elements("convert_uchar4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)double_rounded_values_rte[i]));
    actual.value = convert_uchar4_rte((double4)double_values[i]);
    compare_uchar_elements("convert_uchar4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rte((double4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)double_rounded_values_rtz[i]));
    actual.value = convert_uchar4_rtz((double4)double_values[i]);
    compare_uchar_elements("convert_uchar4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rtz((double4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)double_rounded_values_rtp[i]));
    actual.value = convert_uchar4_rtp((double4)double_values[i]);
    compare_uchar_elements("convert_uchar4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rtp((double4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uchar4)((uchar)double_rounded_values_rtn[i]));
    actual.value = convert_uchar4_rtn((double4)double_values[i]);
    compare_uchar_elements("convert_uchar4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uchar4)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar4)max_expected;
    }
    actual.value = convert_uchar4_sat_rtn((double4)sat_input);
    compare_uchar_elements("convert_uchar4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UCHAR_MAX < DBL_MAX) ? (double)UCHAR_MAX : DBL_MAX;
    union { uchar8 value; uchar raw[8]; } expected, actual;
    expected.value = ((uchar8)((uchar)double_rounded_values[i]));
    actual.value = convert_uchar8((double8)double_values[i]);
    compare_uchar_elements("convert_uchar8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat((double8)sat_input);
    compare_uchar_elements("convert_uchar8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)double_rounded_values_rte[i]));
    actual.value = convert_uchar8_rte((double8)double_values[i]);
    compare_uchar_elements("convert_uchar8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rte((double8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)double_rounded_values_rtz[i]));
    actual.value = convert_uchar8_rtz((double8)double_values[i]);
    compare_uchar_elements("convert_uchar8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rtz((double8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)double_rounded_values_rtp[i]));
    actual.value = convert_uchar8_rtp((double8)double_values[i]);
    compare_uchar_elements("convert_uchar8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rtp((double8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uchar8)((uchar)double_rounded_values_rtn[i]));
    actual.value = convert_uchar8_rtn((double8)double_values[i]);
    compare_uchar_elements("convert_uchar8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uchar8)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar8)max_expected;
    }
    actual.value = convert_uchar8_sat_rtn((double8)sat_input);
    compare_uchar_elements("convert_uchar8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UCHAR_MAX < DBL_MAX) ? (double)UCHAR_MAX : DBL_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)double_rounded_values[i]));
    actual.value = convert_uchar16((double16)double_values[i]);
    compare_uchar_elements("convert_uchar16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((double16)sat_input);
    compare_uchar_elements("convert_uchar16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rte[i]));
    actual.value = convert_uchar16_rte((double16)double_values[i]);
    compare_uchar_elements("convert_uchar16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rte((double16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rtz[i]));
    actual.value = convert_uchar16_rtz((double16)double_values[i]);
    compare_uchar_elements("convert_uchar16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtz((double16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rtp[i]));
    actual.value = convert_uchar16_rtp((double16)double_values[i]);
    compare_uchar_elements("convert_uchar16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtp((double16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rtn[i]));
    actual.value = convert_uchar16_rtn((double16)double_values[i]);
    compare_uchar_elements("convert_uchar16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtn((double16)sat_input);
    compare_uchar_elements("convert_uchar16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (SHRT_MIN > -DBL_MAX) ? (double)SHRT_MIN : -DBL_MAX;
    const double max_expected = (SHRT_MAX < DBL_MAX) ? (double)SHRT_MAX : DBL_MAX;
    union { short value; short raw[1]; } expected, actual;
    expected.value = ((short)((short)double_rounded_values[i]));
    actual.value = convert_short((double)double_values[i]);
    compare_short_elements("convert_short((double))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat((double)sat_input);
    compare_short_elements("convert_short_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)double_rounded_values_rte[i]));
    actual.value = convert_short_rte((double)double_values[i]);
    compare_short_elements("convert_short_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rte((double)sat_input);
    compare_short_elements("convert_short_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)double_rounded_values_rtz[i]));
    actual.value = convert_short_rtz((double)double_values[i]);
    compare_short_elements("convert_short_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rtz((double)sat_input);
    compare_short_elements("convert_short_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)double_rounded_values_rtp[i]));
    actual.value = convert_short_rtp((double)double_values[i]);
    compare_short_elements("convert_short_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rtp((double)sat_input);
    compare_short_elements("convert_short_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((short)((short)double_rounded_values_rtn[i]));
    actual.value = convert_short_rtn((double)double_values[i]);
    compare_short_elements("convert_short_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (short)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short)max_expected;
    }
    actual.value = convert_short_sat_rtn((double)sat_input);
    compare_short_elements("convert_short_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (SHRT_MIN > -DBL_MAX) ? (double)SHRT_MIN : -DBL_MAX;
    const double max_expected = (SHRT_MAX < DBL_MAX) ? (double)SHRT_MAX : DBL_MAX;
    union { short2 value; short raw[2]; } expected, actual;
    expected.value = ((short2)((short)double_rounded_values[i]));
    actual.value = convert_short2((double2)double_values[i]);
    compare_short_elements("convert_short2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat((double2)sat_input);
    compare_short_elements("convert_short2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)double_rounded_values_rte[i]));
    actual.value = convert_short2_rte((double2)double_values[i]);
    compare_short_elements("convert_short2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rte((double2)sat_input);
    compare_short_elements("convert_short2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)double_rounded_values_rtz[i]));
    actual.value = convert_short2_rtz((double2)double_values[i]);
    compare_short_elements("convert_short2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rtz((double2)sat_input);
    compare_short_elements("convert_short2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)double_rounded_values_rtp[i]));
    actual.value = convert_short2_rtp((double2)double_values[i]);
    compare_short_elements("convert_short2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rtp((double2)sat_input);
    compare_short_elements("convert_short2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((short2)((short)double_rounded_values_rtn[i]));
    actual.value = convert_short2_rtn((double2)double_values[i]);
    compare_short_elements("convert_short2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (short2)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short2)max_expected;
    }
    actual.value = convert_short2_sat_rtn((double2)sat_input);
    compare_short_elements("convert_short2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (SHRT_MIN > -DBL_MAX) ? (double)SHRT_MIN : -DBL_MAX;
    const double max_expected = (SHRT_MAX < DBL_MAX) ? (double)SHRT_MAX : DBL_MAX;
    union { short4 value; short raw[4]; } expected, actual;
    expected.value = ((short4)((short)double_rounded_values[i]));
    actual.value = convert_short4((double4)double_values[i]);
    compare_short_elements("convert_short4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat((double4)sat_input);
    compare_short_elements("convert_short4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)double_rounded_values_rte[i]));
    actual.value = convert_short4_rte((double4)double_values[i]);
    compare_short_elements("convert_short4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rte((double4)sat_input);
    compare_short_elements("convert_short4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)double_rounded_values_rtz[i]));
    actual.value = convert_short4_rtz((double4)double_values[i]);
    compare_short_elements("convert_short4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rtz((double4)sat_input);
    compare_short_elements("convert_short4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)double_rounded_values_rtp[i]));
    actual.value = convert_short4_rtp((double4)double_values[i]);
    compare_short_elements("convert_short4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rtp((double4)sat_input);
    compare_short_elements("convert_short4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((short4)((short)double_rounded_values_rtn[i]));
    actual.value = convert_short4_rtn((double4)double_values[i]);
    compare_short_elements("convert_short4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (short4)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short4)max_expected;
    }
    actual.value = convert_short4_sat_rtn((double4)sat_input);
    compare_short_elements("convert_short4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (SHRT_MIN > -DBL_MAX) ? (double)SHRT_MIN : -DBL_MAX;
    const double max_expected = (SHRT_MAX < DBL_MAX) ? (double)SHRT_MAX : DBL_MAX;
    union { short8 value; short raw[8]; } expected, actual;
    expected.value = ((short8)((short)double_rounded_values[i]));
    actual.value = convert_short8((double8)double_values[i]);
    compare_short_elements("convert_short8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat((double8)sat_input);
    compare_short_elements("convert_short8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)double_rounded_values_rte[i]));
    actual.value = convert_short8_rte((double8)double_values[i]);
    compare_short_elements("convert_short8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rte((double8)sat_input);
    compare_short_elements("convert_short8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)double_rounded_values_rtz[i]));
    actual.value = convert_short8_rtz((double8)double_values[i]);
    compare_short_elements("convert_short8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rtz((double8)sat_input);
    compare_short_elements("convert_short8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)double_rounded_values_rtp[i]));
    actual.value = convert_short8_rtp((double8)double_values[i]);
    compare_short_elements("convert_short8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rtp((double8)sat_input);
    compare_short_elements("convert_short8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((short8)((short)double_rounded_values_rtn[i]));
    actual.value = convert_short8_rtn((double8)double_values[i]);
    compare_short_elements("convert_short8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (short8)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short8)max_expected;
    }
    actual.value = convert_short8_sat_rtn((double8)sat_input);
    compare_short_elements("convert_short8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (SHRT_MIN > -DBL_MAX) ? (double)SHRT_MIN : -DBL_MAX;
    const double max_expected = (SHRT_MAX < DBL_MAX) ? (double)SHRT_MAX : DBL_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)double_rounded_values[i]));
    actual.value = convert_short16((double16)double_values[i]);
    compare_short_elements("convert_short16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((double16)sat_input);
    compare_short_elements("convert_short16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rte[i]));
    actual.value = convert_short16_rte((double16)double_values[i]);
    compare_short_elements("convert_short16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rte((double16)sat_input);
    compare_short_elements("convert_short16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rtz[i]));
    actual.value = convert_short16_rtz((double16)double_values[i]);
    compare_short_elements("convert_short16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtz((double16)sat_input);
    compare_short_elements("convert_short16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rtp[i]));
    actual.value = convert_short16_rtp((double16)double_values[i]);
    compare_short_elements("convert_short16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtp((double16)sat_input);
    compare_short_elements("convert_short16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rtn[i]));
    actual.value = convert_short16_rtn((double16)double_values[i]);
    compare_short_elements("convert_short16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtn((double16)sat_input);
    compare_short_elements("convert_short16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (USHRT_MAX < DBL_MAX) ? (double)USHRT_MAX : DBL_MAX;
    union { ushort value; ushort raw[1]; } expected, actual;
    expected.value = ((ushort)((ushort)double_rounded_values[i]));
    actual.value = convert_ushort((double)double_values[i]);
    compare_ushort_elements("convert_ushort((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat((double)sat_input);
    compare_ushort_elements("convert_ushort_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)double_rounded_values_rte[i]));
    actual.value = convert_ushort_rte((double)double_values[i]);
    compare_ushort_elements("convert_ushort_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rte((double)sat_input);
    compare_ushort_elements("convert_ushort_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)double_rounded_values_rtz[i]));
    actual.value = convert_ushort_rtz((double)double_values[i]);
    compare_ushort_elements("convert_ushort_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rtz((double)sat_input);
    compare_ushort_elements("convert_ushort_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)double_rounded_values_rtp[i]));
    actual.value = convert_ushort_rtp((double)double_values[i]);
    compare_ushort_elements("convert_ushort_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rtp((double)sat_input);
    compare_ushort_elements("convert_ushort_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ushort)((ushort)double_rounded_values_rtn[i]));
    actual.value = convert_ushort_rtn((double)double_values[i]);
    compare_ushort_elements("convert_ushort_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ushort)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort)max_expected;
    }
    actual.value = convert_ushort_sat_rtn((double)sat_input);
    compare_ushort_elements("convert_ushort_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (USHRT_MAX < DBL_MAX) ? (double)USHRT_MAX : DBL_MAX;
    union { ushort2 value; ushort raw[2]; } expected, actual;
    expected.value = ((ushort2)((ushort)double_rounded_values[i]));
    actual.value = convert_ushort2((double2)double_values[i]);
    compare_ushort_elements("convert_ushort2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat((double2)sat_input);
    compare_ushort_elements("convert_ushort2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)double_rounded_values_rte[i]));
    actual.value = convert_ushort2_rte((double2)double_values[i]);
    compare_ushort_elements("convert_ushort2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rte((double2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)double_rounded_values_rtz[i]));
    actual.value = convert_ushort2_rtz((double2)double_values[i]);
    compare_ushort_elements("convert_ushort2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rtz((double2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)double_rounded_values_rtp[i]));
    actual.value = convert_ushort2_rtp((double2)double_values[i]);
    compare_ushort_elements("convert_ushort2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rtp((double2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ushort2)((ushort)double_rounded_values_rtn[i]));
    actual.value = convert_ushort2_rtn((double2)double_values[i]);
    compare_ushort_elements("convert_ushort2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ushort2)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort2)max_expected;
    }
    actual.value = convert_ushort2_sat_rtn((double2)sat_input);
    compare_ushort_elements("convert_ushort2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (USHRT_MAX < DBL_MAX) ? (double)USHRT_MAX : DBL_MAX;
    union { ushort4 value; ushort raw[4]; } expected, actual;
    expected.value = ((ushort4)((ushort)double_rounded_values[i]));
    actual.value = convert_ushort4((double4)double_values[i]);
    compare_ushort_elements("convert_ushort4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat((double4)sat_input);
    compare_ushort_elements("convert_ushort4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)double_rounded_values_rte[i]));
    actual.value = convert_ushort4_rte((double4)double_values[i]);
    compare_ushort_elements("convert_ushort4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rte((double4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)double_rounded_values_rtz[i]));
    actual.value = convert_ushort4_rtz((double4)double_values[i]);
    compare_ushort_elements("convert_ushort4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rtz((double4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)double_rounded_values_rtp[i]));
    actual.value = convert_ushort4_rtp((double4)double_values[i]);
    compare_ushort_elements("convert_ushort4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rtp((double4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ushort4)((ushort)double_rounded_values_rtn[i]));
    actual.value = convert_ushort4_rtn((double4)double_values[i]);
    compare_ushort_elements("convert_ushort4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ushort4)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort4)max_expected;
    }
    actual.value = convert_ushort4_sat_rtn((double4)sat_input);
    compare_ushort_elements("convert_ushort4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (USHRT_MAX < DBL_MAX) ? (double)USHRT_MAX : DBL_MAX;
    union { ushort8 value; ushort raw[8]; } expected, actual;
    expected.value = ((ushort8)((ushort)double_rounded_values[i]));
    actual.value = convert_ushort8((double8)double_values[i]);
    compare_ushort_elements("convert_ushort8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat((double8)sat_input);
    compare_ushort_elements("convert_ushort8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)double_rounded_values_rte[i]));
    actual.value = convert_ushort8_rte((double8)double_values[i]);
    compare_ushort_elements("convert_ushort8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rte((double8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)double_rounded_values_rtz[i]));
    actual.value = convert_ushort8_rtz((double8)double_values[i]);
    compare_ushort_elements("convert_ushort8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rtz((double8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)double_rounded_values_rtp[i]));
    actual.value = convert_ushort8_rtp((double8)double_values[i]);
    compare_ushort_elements("convert_ushort8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rtp((double8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ushort8)((ushort)double_rounded_values_rtn[i]));
    actual.value = convert_ushort8_rtn((double8)double_values[i]);
    compare_ushort_elements("convert_ushort8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ushort8)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort8)max_expected;
    }
    actual.value = convert_ushort8_sat_rtn((double8)sat_input);
    compare_ushort_elements("convert_ushort8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (USHRT_MAX < DBL_MAX) ? (double)USHRT_MAX : DBL_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)double_rounded_values[i]));
    actual.value = convert_ushort16((double16)double_values[i]);
    compare_ushort_elements("convert_ushort16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((double16)sat_input);
    compare_ushort_elements("convert_ushort16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rte[i]));
    actual.value = convert_ushort16_rte((double16)double_values[i]);
    compare_ushort_elements("convert_ushort16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rte((double16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rtz[i]));
    actual.value = convert_ushort16_rtz((double16)double_values[i]);
    compare_ushort_elements("convert_ushort16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtz((double16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rtp[i]));
    actual.value = convert_ushort16_rtp((double16)double_values[i]);
    compare_ushort_elements("convert_ushort16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtp((double16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rtn[i]));
    actual.value = convert_ushort16_rtn((double16)double_values[i]);
    compare_ushort_elements("convert_ushort16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtn((double16)sat_input);
    compare_ushort_elements("convert_ushort16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (INT_MIN > -DBL_MAX) ? (double)INT_MIN : -DBL_MAX;
    const double max_expected = (INT_MAX < DBL_MAX) ? (double)INT_MAX : DBL_MAX;
    union { int value; int raw[1]; } expected, actual;
    expected.value = ((int)((int)double_rounded_values[i]));
    actual.value = convert_int((double)double_values[i]);
    compare_int_elements("convert_int((double))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat((double)sat_input);
    compare_int_elements("convert_int_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)double_rounded_values_rte[i]));
    actual.value = convert_int_rte((double)double_values[i]);
    compare_int_elements("convert_int_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rte((double)sat_input);
    compare_int_elements("convert_int_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)double_rounded_values_rtz[i]));
    actual.value = convert_int_rtz((double)double_values[i]);
    compare_int_elements("convert_int_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rtz((double)sat_input);
    compare_int_elements("convert_int_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)double_rounded_values_rtp[i]));
    actual.value = convert_int_rtp((double)double_values[i]);
    compare_int_elements("convert_int_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rtp((double)sat_input);
    compare_int_elements("convert_int_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((int)((int)double_rounded_values_rtn[i]));
    actual.value = convert_int_rtn((double)double_values[i]);
    compare_int_elements("convert_int_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (int)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int)max_expected;
    }
    actual.value = convert_int_sat_rtn((double)sat_input);
    compare_int_elements("convert_int_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (INT_MIN > -DBL_MAX) ? (double)INT_MIN : -DBL_MAX;
    const double max_expected = (INT_MAX < DBL_MAX) ? (double)INT_MAX : DBL_MAX;
    union { int2 value; int raw[2]; } expected, actual;
    expected.value = ((int2)((int)double_rounded_values[i]));
    actual.value = convert_int2((double2)double_values[i]);
    compare_int_elements("convert_int2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat((double2)sat_input);
    compare_int_elements("convert_int2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)double_rounded_values_rte[i]));
    actual.value = convert_int2_rte((double2)double_values[i]);
    compare_int_elements("convert_int2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rte((double2)sat_input);
    compare_int_elements("convert_int2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)double_rounded_values_rtz[i]));
    actual.value = convert_int2_rtz((double2)double_values[i]);
    compare_int_elements("convert_int2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rtz((double2)sat_input);
    compare_int_elements("convert_int2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)double_rounded_values_rtp[i]));
    actual.value = convert_int2_rtp((double2)double_values[i]);
    compare_int_elements("convert_int2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rtp((double2)sat_input);
    compare_int_elements("convert_int2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((int2)((int)double_rounded_values_rtn[i]));
    actual.value = convert_int2_rtn((double2)double_values[i]);
    compare_int_elements("convert_int2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (int2)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int2)max_expected;
    }
    actual.value = convert_int2_sat_rtn((double2)sat_input);
    compare_int_elements("convert_int2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (INT_MIN > -DBL_MAX) ? (double)INT_MIN : -DBL_MAX;
    const double max_expected = (INT_MAX < DBL_MAX) ? (double)INT_MAX : DBL_MAX;
    union { int4 value; int raw[4]; } expected, actual;
    expected.value = ((int4)((int)double_rounded_values[i]));
    actual.value = convert_int4((double4)double_values[i]);
    compare_int_elements("convert_int4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat((double4)sat_input);
    compare_int_elements("convert_int4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)double_rounded_values_rte[i]));
    actual.value = convert_int4_rte((double4)double_values[i]);
    compare_int_elements("convert_int4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rte((double4)sat_input);
    compare_int_elements("convert_int4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)double_rounded_values_rtz[i]));
    actual.value = convert_int4_rtz((double4)double_values[i]);
    compare_int_elements("convert_int4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rtz((double4)sat_input);
    compare_int_elements("convert_int4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)double_rounded_values_rtp[i]));
    actual.value = convert_int4_rtp((double4)double_values[i]);
    compare_int_elements("convert_int4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rtp((double4)sat_input);
    compare_int_elements("convert_int4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((int4)((int)double_rounded_values_rtn[i]));
    actual.value = convert_int4_rtn((double4)double_values[i]);
    compare_int_elements("convert_int4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (int4)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int4)max_expected;
    }
    actual.value = convert_int4_sat_rtn((double4)sat_input);
    compare_int_elements("convert_int4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (INT_MIN > -DBL_MAX) ? (double)INT_MIN : -DBL_MAX;
    const double max_expected = (INT_MAX < DBL_MAX) ? (double)INT_MAX : DBL_MAX;
    union { int8 value; int raw[8]; } expected, actual;
    expected.value = ((int8)((int)double_rounded_values[i]));
    actual.value = convert_int8((double8)double_values[i]);
    compare_int_elements("convert_int8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat((double8)sat_input);
    compare_int_elements("convert_int8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)double_rounded_values_rte[i]));
    actual.value = convert_int8_rte((double8)double_values[i]);
    compare_int_elements("convert_int8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rte((double8)sat_input);
    compare_int_elements("convert_int8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)double_rounded_values_rtz[i]));
    actual.value = convert_int8_rtz((double8)double_values[i]);
    compare_int_elements("convert_int8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rtz((double8)sat_input);
    compare_int_elements("convert_int8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)double_rounded_values_rtp[i]));
    actual.value = convert_int8_rtp((double8)double_values[i]);
    compare_int_elements("convert_int8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rtp((double8)sat_input);
    compare_int_elements("convert_int8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((int8)((int)double_rounded_values_rtn[i]));
    actual.value = convert_int8_rtn((double8)double_values[i]);
    compare_int_elements("convert_int8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (int8)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int8)max_expected;
    }
    actual.value = convert_int8_sat_rtn((double8)sat_input);
    compare_int_elements("convert_int8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (INT_MIN > -DBL_MAX) ? (double)INT_MIN : -DBL_MAX;
    const double max_expected = (INT_MAX < DBL_MAX) ? (double)INT_MAX : DBL_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)double_rounded_values[i]));
    actual.value = convert_int16((double16)double_values[i]);
    compare_int_elements("convert_int16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((double16)sat_input);
    compare_int_elements("convert_int16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rte[i]));
    actual.value = convert_int16_rte((double16)double_values[i]);
    compare_int_elements("convert_int16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rte((double16)sat_input);
    compare_int_elements("convert_int16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rtz[i]));
    actual.value = convert_int16_rtz((double16)double_values[i]);
    compare_int_elements("convert_int16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtz((double16)sat_input);
    compare_int_elements("convert_int16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rtp[i]));
    actual.value = convert_int16_rtp((double16)double_values[i]);
    compare_int_elements("convert_int16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtp((double16)sat_input);
    compare_int_elements("convert_int16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rtn[i]));
    actual.value = convert_int16_rtn((double16)double_values[i]);
    compare_int_elements("convert_int16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtn((double16)sat_input);
    compare_int_elements("convert_int16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UINT_MAX < DBL_MAX) ? (double)UINT_MAX : DBL_MAX;
    union { uint value; uint raw[1]; } expected, actual;
    expected.value = ((uint)((uint)double_rounded_values[i]));
    actual.value = convert_uint((double)double_values[i]);
    compare_uint_elements("convert_uint((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat((double)sat_input);
    compare_uint_elements("convert_uint_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)double_rounded_values_rte[i]));
    actual.value = convert_uint_rte((double)double_values[i]);
    compare_uint_elements("convert_uint_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rte((double)sat_input);
    compare_uint_elements("convert_uint_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)double_rounded_values_rtz[i]));
    actual.value = convert_uint_rtz((double)double_values[i]);
    compare_uint_elements("convert_uint_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rtz((double)sat_input);
    compare_uint_elements("convert_uint_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)double_rounded_values_rtp[i]));
    actual.value = convert_uint_rtp((double)double_values[i]);
    compare_uint_elements("convert_uint_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rtp((double)sat_input);
    compare_uint_elements("convert_uint_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((uint)((uint)double_rounded_values_rtn[i]));
    actual.value = convert_uint_rtn((double)double_values[i]);
    compare_uint_elements("convert_uint_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (uint)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint)max_expected;
    }
    actual.value = convert_uint_sat_rtn((double)sat_input);
    compare_uint_elements("convert_uint_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UINT_MAX < DBL_MAX) ? (double)UINT_MAX : DBL_MAX;
    union { uint2 value; uint raw[2]; } expected, actual;
    expected.value = ((uint2)((uint)double_rounded_values[i]));
    actual.value = convert_uint2((double2)double_values[i]);
    compare_uint_elements("convert_uint2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat((double2)sat_input);
    compare_uint_elements("convert_uint2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)double_rounded_values_rte[i]));
    actual.value = convert_uint2_rte((double2)double_values[i]);
    compare_uint_elements("convert_uint2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rte((double2)sat_input);
    compare_uint_elements("convert_uint2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)double_rounded_values_rtz[i]));
    actual.value = convert_uint2_rtz((double2)double_values[i]);
    compare_uint_elements("convert_uint2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rtz((double2)sat_input);
    compare_uint_elements("convert_uint2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)double_rounded_values_rtp[i]));
    actual.value = convert_uint2_rtp((double2)double_values[i]);
    compare_uint_elements("convert_uint2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rtp((double2)sat_input);
    compare_uint_elements("convert_uint2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((uint2)((uint)double_rounded_values_rtn[i]));
    actual.value = convert_uint2_rtn((double2)double_values[i]);
    compare_uint_elements("convert_uint2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (uint2)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint2)max_expected;
    }
    actual.value = convert_uint2_sat_rtn((double2)sat_input);
    compare_uint_elements("convert_uint2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UINT_MAX < DBL_MAX) ? (double)UINT_MAX : DBL_MAX;
    union { uint4 value; uint raw[4]; } expected, actual;
    expected.value = ((uint4)((uint)double_rounded_values[i]));
    actual.value = convert_uint4((double4)double_values[i]);
    compare_uint_elements("convert_uint4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat((double4)sat_input);
    compare_uint_elements("convert_uint4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)double_rounded_values_rte[i]));
    actual.value = convert_uint4_rte((double4)double_values[i]);
    compare_uint_elements("convert_uint4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rte((double4)sat_input);
    compare_uint_elements("convert_uint4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)double_rounded_values_rtz[i]));
    actual.value = convert_uint4_rtz((double4)double_values[i]);
    compare_uint_elements("convert_uint4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rtz((double4)sat_input);
    compare_uint_elements("convert_uint4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)double_rounded_values_rtp[i]));
    actual.value = convert_uint4_rtp((double4)double_values[i]);
    compare_uint_elements("convert_uint4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rtp((double4)sat_input);
    compare_uint_elements("convert_uint4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((uint4)((uint)double_rounded_values_rtn[i]));
    actual.value = convert_uint4_rtn((double4)double_values[i]);
    compare_uint_elements("convert_uint4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (uint4)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint4)max_expected;
    }
    actual.value = convert_uint4_sat_rtn((double4)sat_input);
    compare_uint_elements("convert_uint4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UINT_MAX < DBL_MAX) ? (double)UINT_MAX : DBL_MAX;
    union { uint8 value; uint raw[8]; } expected, actual;
    expected.value = ((uint8)((uint)double_rounded_values[i]));
    actual.value = convert_uint8((double8)double_values[i]);
    compare_uint_elements("convert_uint8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat((double8)sat_input);
    compare_uint_elements("convert_uint8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)double_rounded_values_rte[i]));
    actual.value = convert_uint8_rte((double8)double_values[i]);
    compare_uint_elements("convert_uint8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rte((double8)sat_input);
    compare_uint_elements("convert_uint8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)double_rounded_values_rtz[i]));
    actual.value = convert_uint8_rtz((double8)double_values[i]);
    compare_uint_elements("convert_uint8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rtz((double8)sat_input);
    compare_uint_elements("convert_uint8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)double_rounded_values_rtp[i]));
    actual.value = convert_uint8_rtp((double8)double_values[i]);
    compare_uint_elements("convert_uint8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rtp((double8)sat_input);
    compare_uint_elements("convert_uint8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((uint8)((uint)double_rounded_values_rtn[i]));
    actual.value = convert_uint8_rtn((double8)double_values[i]);
    compare_uint_elements("convert_uint8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (uint8)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint8)max_expected;
    }
    actual.value = convert_uint8_sat_rtn((double8)sat_input);
    compare_uint_elements("convert_uint8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (UINT_MAX < DBL_MAX) ? (double)UINT_MAX : DBL_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)double_rounded_values[i]));
    actual.value = convert_uint16((double16)double_values[i]);
    compare_uint_elements("convert_uint16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((double16)sat_input);
    compare_uint_elements("convert_uint16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rte[i]));
    actual.value = convert_uint16_rte((double16)double_values[i]);
    compare_uint_elements("convert_uint16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rte((double16)sat_input);
    compare_uint_elements("convert_uint16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rtz[i]));
    actual.value = convert_uint16_rtz((double16)double_values[i]);
    compare_uint_elements("convert_uint16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtz((double16)sat_input);
    compare_uint_elements("convert_uint16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rtp[i]));
    actual.value = convert_uint16_rtp((double16)double_values[i]);
    compare_uint_elements("convert_uint16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtp((double16)sat_input);
    compare_uint_elements("convert_uint16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rtn[i]));
    actual.value = convert_uint16_rtn((double16)double_values[i]);
    compare_uint_elements("convert_uint16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtn((double16)sat_input);
    compare_uint_elements("convert_uint16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (LONG_MIN > -DBL_MAX) ? (double)LONG_MIN : -DBL_MAX;
    const double max_expected = (LONG_MAX < DBL_MAX) ? (double)LONG_MAX : DBL_MAX;
    union { long value; long raw[1]; } expected, actual;
    expected.value = ((long)((long)double_rounded_values[i]));
    actual.value = convert_long((double)double_values[i]);
    compare_long_elements("convert_long((double))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat((double)sat_input);
    compare_long_elements("convert_long_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)double_rounded_values_rte[i]));
    actual.value = convert_long_rte((double)double_values[i]);
    compare_long_elements("convert_long_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rte((double)sat_input);
    compare_long_elements("convert_long_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)double_rounded_values_rtz[i]));
    actual.value = convert_long_rtz((double)double_values[i]);
    compare_long_elements("convert_long_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rtz((double)sat_input);
    compare_long_elements("convert_long_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)double_rounded_values_rtp[i]));
    actual.value = convert_long_rtp((double)double_values[i]);
    compare_long_elements("convert_long_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rtp((double)sat_input);
    compare_long_elements("convert_long_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((long)((long)double_rounded_values_rtn[i]));
    actual.value = convert_long_rtn((double)double_values[i]);
    compare_long_elements("convert_long_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (long)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long)max_expected;
    }
    actual.value = convert_long_sat_rtn((double)sat_input);
    compare_long_elements("convert_long_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (LONG_MIN > -DBL_MAX) ? (double)LONG_MIN : -DBL_MAX;
    const double max_expected = (LONG_MAX < DBL_MAX) ? (double)LONG_MAX : DBL_MAX;
    union { long2 value; long raw[2]; } expected, actual;
    expected.value = ((long2)((long)double_rounded_values[i]));
    actual.value = convert_long2((double2)double_values[i]);
    compare_long_elements("convert_long2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat((double2)sat_input);
    compare_long_elements("convert_long2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)double_rounded_values_rte[i]));
    actual.value = convert_long2_rte((double2)double_values[i]);
    compare_long_elements("convert_long2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rte((double2)sat_input);
    compare_long_elements("convert_long2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)double_rounded_values_rtz[i]));
    actual.value = convert_long2_rtz((double2)double_values[i]);
    compare_long_elements("convert_long2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rtz((double2)sat_input);
    compare_long_elements("convert_long2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)double_rounded_values_rtp[i]));
    actual.value = convert_long2_rtp((double2)double_values[i]);
    compare_long_elements("convert_long2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rtp((double2)sat_input);
    compare_long_elements("convert_long2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((long2)((long)double_rounded_values_rtn[i]));
    actual.value = convert_long2_rtn((double2)double_values[i]);
    compare_long_elements("convert_long2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (long2)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long2)max_expected;
    }
    actual.value = convert_long2_sat_rtn((double2)sat_input);
    compare_long_elements("convert_long2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (LONG_MIN > -DBL_MAX) ? (double)LONG_MIN : -DBL_MAX;
    const double max_expected = (LONG_MAX < DBL_MAX) ? (double)LONG_MAX : DBL_MAX;
    union { long4 value; long raw[4]; } expected, actual;
    expected.value = ((long4)((long)double_rounded_values[i]));
    actual.value = convert_long4((double4)double_values[i]);
    compare_long_elements("convert_long4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat((double4)sat_input);
    compare_long_elements("convert_long4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)double_rounded_values_rte[i]));
    actual.value = convert_long4_rte((double4)double_values[i]);
    compare_long_elements("convert_long4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rte((double4)sat_input);
    compare_long_elements("convert_long4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)double_rounded_values_rtz[i]));
    actual.value = convert_long4_rtz((double4)double_values[i]);
    compare_long_elements("convert_long4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rtz((double4)sat_input);
    compare_long_elements("convert_long4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)double_rounded_values_rtp[i]));
    actual.value = convert_long4_rtp((double4)double_values[i]);
    compare_long_elements("convert_long4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rtp((double4)sat_input);
    compare_long_elements("convert_long4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((long4)((long)double_rounded_values_rtn[i]));
    actual.value = convert_long4_rtn((double4)double_values[i]);
    compare_long_elements("convert_long4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (long4)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long4)max_expected;
    }
    actual.value = convert_long4_sat_rtn((double4)sat_input);
    compare_long_elements("convert_long4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (LONG_MIN > -DBL_MAX) ? (double)LONG_MIN : -DBL_MAX;
    const double max_expected = (LONG_MAX < DBL_MAX) ? (double)LONG_MAX : DBL_MAX;
    union { long8 value; long raw[8]; } expected, actual;
    expected.value = ((long8)((long)double_rounded_values[i]));
    actual.value = convert_long8((double8)double_values[i]);
    compare_long_elements("convert_long8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat((double8)sat_input);
    compare_long_elements("convert_long8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)double_rounded_values_rte[i]));
    actual.value = convert_long8_rte((double8)double_values[i]);
    compare_long_elements("convert_long8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rte((double8)sat_input);
    compare_long_elements("convert_long8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)double_rounded_values_rtz[i]));
    actual.value = convert_long8_rtz((double8)double_values[i]);
    compare_long_elements("convert_long8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rtz((double8)sat_input);
    compare_long_elements("convert_long8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)double_rounded_values_rtp[i]));
    actual.value = convert_long8_rtp((double8)double_values[i]);
    compare_long_elements("convert_long8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rtp((double8)sat_input);
    compare_long_elements("convert_long8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((long8)((long)double_rounded_values_rtn[i]));
    actual.value = convert_long8_rtn((double8)double_values[i]);
    compare_long_elements("convert_long8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (long8)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long8)max_expected;
    }
    actual.value = convert_long8_sat_rtn((double8)sat_input);
    compare_long_elements("convert_long8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (LONG_MIN > -DBL_MAX) ? (double)LONG_MIN : -DBL_MAX;
    const double max_expected = (LONG_MAX < DBL_MAX) ? (double)LONG_MAX : DBL_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)double_rounded_values[i]));
    actual.value = convert_long16((double16)double_values[i]);
    compare_long_elements("convert_long16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((double16)sat_input);
    compare_long_elements("convert_long16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rte[i]));
    actual.value = convert_long16_rte((double16)double_values[i]);
    compare_long_elements("convert_long16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rte((double16)sat_input);
    compare_long_elements("convert_long16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rtz[i]));
    actual.value = convert_long16_rtz((double16)double_values[i]);
    compare_long_elements("convert_long16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtz((double16)sat_input);
    compare_long_elements("convert_long16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rtp[i]));
    actual.value = convert_long16_rtp((double16)double_values[i]);
    compare_long_elements("convert_long16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtp((double16)sat_input);
    compare_long_elements("convert_long16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rtn[i]));
    actual.value = convert_long16_rtn((double16)double_values[i]);
    compare_long_elements("convert_long16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtn((double16)sat_input);
    compare_long_elements("convert_long16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (ULONG_MAX < DBL_MAX) ? (double)ULONG_MAX : DBL_MAX;
    union { ulong value; ulong raw[1]; } expected, actual;
    expected.value = ((ulong)((ulong)double_rounded_values[i]));
    actual.value = convert_ulong((double)double_values[i]);
    compare_ulong_elements("convert_ulong((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat((double)sat_input);
    compare_ulong_elements("convert_ulong_sat((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)double_rounded_values_rte[i]));
    actual.value = convert_ulong_rte((double)double_values[i]);
    compare_ulong_elements("convert_ulong_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rte((double)sat_input);
    compare_ulong_elements("convert_ulong_sat_rte((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)double_rounded_values_rtz[i]));
    actual.value = convert_ulong_rtz((double)double_values[i]);
    compare_ulong_elements("convert_ulong_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rtz((double)sat_input);
    compare_ulong_elements("convert_ulong_sat_rtz((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)double_rounded_values_rtp[i]));
    actual.value = convert_ulong_rtp((double)double_values[i]);
    compare_ulong_elements("convert_ulong_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rtp((double)sat_input);
    compare_ulong_elements("convert_ulong_sat_rtp((double))", i, expected.raw, actual.raw, 1);
    expected.value = ((ulong)((ulong)double_rounded_values_rtn[i]));
    actual.value = convert_ulong_rtn((double)double_values[i]);
    compare_ulong_elements("convert_ulong_rtn((double))", i, expected.raw, actual.raw, 1);
    expected.value = (ulong)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong)max_expected;
    }
    actual.value = convert_ulong_sat_rtn((double)sat_input);
    compare_ulong_elements("convert_ulong_sat_rtn((double))", i, expected.raw, actual.raw, 1);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (ULONG_MAX < DBL_MAX) ? (double)ULONG_MAX : DBL_MAX;
    union { ulong2 value; ulong raw[2]; } expected, actual;
    expected.value = ((ulong2)((ulong)double_rounded_values[i]));
    actual.value = convert_ulong2((double2)double_values[i]);
    compare_ulong_elements("convert_ulong2((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat((double2)sat_input);
    compare_ulong_elements("convert_ulong2_sat((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)double_rounded_values_rte[i]));
    actual.value = convert_ulong2_rte((double2)double_values[i]);
    compare_ulong_elements("convert_ulong2_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rte((double2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rte((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)double_rounded_values_rtz[i]));
    actual.value = convert_ulong2_rtz((double2)double_values[i]);
    compare_ulong_elements("convert_ulong2_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rtz((double2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rtz((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)double_rounded_values_rtp[i]));
    actual.value = convert_ulong2_rtp((double2)double_values[i]);
    compare_ulong_elements("convert_ulong2_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rtp((double2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rtp((double2))", i, expected.raw, actual.raw, 2);
    expected.value = ((ulong2)((ulong)double_rounded_values_rtn[i]));
    actual.value = convert_ulong2_rtn((double2)double_values[i]);
    compare_ulong_elements("convert_ulong2_rtn((double2))", i, expected.raw, actual.raw, 2);
    expected.value = (ulong2)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong2)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong2)max_expected;
    }
    actual.value = convert_ulong2_sat_rtn((double2)sat_input);
    compare_ulong_elements("convert_ulong2_sat_rtn((double2))", i, expected.raw, actual.raw, 2);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (ULONG_MAX < DBL_MAX) ? (double)ULONG_MAX : DBL_MAX;
    union { ulong4 value; ulong raw[4]; } expected, actual;
    expected.value = ((ulong4)((ulong)double_rounded_values[i]));
    actual.value = convert_ulong4((double4)double_values[i]);
    compare_ulong_elements("convert_ulong4((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat((double4)sat_input);
    compare_ulong_elements("convert_ulong4_sat((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)double_rounded_values_rte[i]));
    actual.value = convert_ulong4_rte((double4)double_values[i]);
    compare_ulong_elements("convert_ulong4_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rte((double4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rte((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)double_rounded_values_rtz[i]));
    actual.value = convert_ulong4_rtz((double4)double_values[i]);
    compare_ulong_elements("convert_ulong4_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rtz((double4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rtz((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)double_rounded_values_rtp[i]));
    actual.value = convert_ulong4_rtp((double4)double_values[i]);
    compare_ulong_elements("convert_ulong4_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rtp((double4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rtp((double4))", i, expected.raw, actual.raw, 4);
    expected.value = ((ulong4)((ulong)double_rounded_values_rtn[i]));
    actual.value = convert_ulong4_rtn((double4)double_values[i]);
    compare_ulong_elements("convert_ulong4_rtn((double4))", i, expected.raw, actual.raw, 4);
    expected.value = (ulong4)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong4)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong4)max_expected;
    }
    actual.value = convert_ulong4_sat_rtn((double4)sat_input);
    compare_ulong_elements("convert_ulong4_sat_rtn((double4))", i, expected.raw, actual.raw, 4);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (ULONG_MAX < DBL_MAX) ? (double)ULONG_MAX : DBL_MAX;
    union { ulong8 value; ulong raw[8]; } expected, actual;
    expected.value = ((ulong8)((ulong)double_rounded_values[i]));
    actual.value = convert_ulong8((double8)double_values[i]);
    compare_ulong_elements("convert_ulong8((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat((double8)sat_input);
    compare_ulong_elements("convert_ulong8_sat((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)double_rounded_values_rte[i]));
    actual.value = convert_ulong8_rte((double8)double_values[i]);
    compare_ulong_elements("convert_ulong8_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rte((double8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rte((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)double_rounded_values_rtz[i]));
    actual.value = convert_ulong8_rtz((double8)double_values[i]);
    compare_ulong_elements("convert_ulong8_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rtz((double8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rtz((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)double_rounded_values_rtp[i]));
    actual.value = convert_ulong8_rtp((double8)double_values[i]);
    compare_ulong_elements("convert_ulong8_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rtp((double8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rtp((double8))", i, expected.raw, actual.raw, 8);
    expected.value = ((ulong8)((ulong)double_rounded_values_rtn[i]));
    actual.value = convert_ulong8_rtn((double8)double_values[i]);
    compare_ulong_elements("convert_ulong8_rtn((double8))", i, expected.raw, actual.raw, 8);
    expected.value = (ulong8)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong8)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong8)max_expected;
    }
    actual.value = convert_ulong8_sat_rtn((double8)sat_input);
    compare_ulong_elements("convert_ulong8_sat_rtn((double8))", i, expected.raw, actual.raw, 8);
  }

#endif

#endif

#ifdef cles_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    const double min_expected = (0 > -DBL_MAX) ? (double)0 : -DBL_MAX;
    const double max_expected = (ULONG_MAX < DBL_MAX) ? (double)ULONG_MAX : DBL_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)double_rounded_values[i]));
    actual.value = convert_ulong16((double16)double_values[i]);
    compare_ulong_elements("convert_ulong16((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((double16)sat_input);
    compare_ulong_elements("convert_ulong16_sat((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rte[i]));
    actual.value = convert_ulong16_rte((double16)double_values[i]);
    compare_ulong_elements("convert_ulong16_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rte(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rte((double16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rte((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rtz[i]));
    actual.value = convert_ulong16_rtz((double16)double_values[i]);
    compare_ulong_elements("convert_ulong16_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtz(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtz((double16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rtz((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rtp[i]));
    actual.value = convert_ulong16_rtp((double16)double_values[i]);
    compare_ulong_elements("convert_ulong16_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtp(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtp((double16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rtp((double16))", i, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rtn[i]));
    actual.value = convert_ulong16_rtn((double16)double_values[i]);
    compare_ulong_elements("convert_ulong16_rtn((double16))", i, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtn(sat_input);
    if (sat_input < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtn((double16)sat_input);
    compare_ulong_elements("convert_ulong16_sat_rtn((double16))", i, expected.raw, actual.raw, 16);
  }

#endif

#endif

union { int8 value; int raw[8]; } qe, qa;
qa.value = convert_int8_rtz((float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f));
qe.value = (int8)(-23, -23, -23, -23, 23, 23, 23, 23);
compare_int_elements("convert_int8_rtz((float8))", 0, qe.raw, qa.raw, 8);

qa.value = convert_int8_rtp((float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f));
qe.value = (int8)(-23, -23, -23, -23, 23, 24, 24, 24);
compare_int_elements("convert_int8_rtp((float8))", 0, qe.raw, qa.raw, 8);

qa.value = convert_int8_rtn((float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f));
qe.value = (int8)(-24, -24, -24, -23, 23, 23, 23, 23);
compare_int_elements("convert_int8_rtn((float8))", 0, qe.raw, qa.raw, 8);

qa.value = convert_int8_rte((float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f));
qe.value = (int8)(-24, -24, -23, -23, 23, 23, 24, 24);
compare_int_elements("convert_int8_rte((float8))", 0, qe.raw, qa.raw, 8);

qa.value = convert_int8((float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f));
qe.value = (int8)(-23, -23, -23, -23, 23, 23, 23, 23);
compare_int_elements("convert_int8((float8))", 0, qe.raw, qa.raw, 8);

}
