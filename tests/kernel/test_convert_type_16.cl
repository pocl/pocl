/* !!!! AUTOGENERATED FILE generated by test_convert_type.py !!!!!

   DO NOT CHANGE THIS FILE. MAKE YOUR CHANGES TO test_convert_type.py AND RUN:
   $ python3 test_convert_type.py > test_convert_type.cl
*/

#include "common.cl"

constant char char_values[6] = { 0, 1, CHAR_MIN, CHAR_MAX, CHAR_MIN / 2, CHAR_MAX / 2 };
constant uchar uchar_values[6] = { 0, 1, 0, UCHAR_MAX, 0 / 2, UCHAR_MAX / 2 };
constant short short_values[6] = { 0, 1, SHRT_MIN, SHRT_MAX, SHRT_MIN / 2, SHRT_MAX / 2 };
constant ushort ushort_values[6] = { 0, 1, 0, USHRT_MAX, 0 / 2, USHRT_MAX / 2 };
constant int int_values[6] = { 0, 1, INT_MIN, INT_MAX, INT_MIN / 2, INT_MAX / 2 };
constant uint uint_values[6] = { 0, 1, 0, UINT_MAX, 0 / 2, UINT_MAX / 2 };

constant size_t char_values_length = sizeof(char_values) / sizeof(char_values[0]);
constant size_t uchar_values_length = sizeof(uchar_values) / sizeof(uchar_values[0]);
constant size_t short_values_length = sizeof(short_values) / sizeof(short_values[0]);
constant size_t ushort_values_length = sizeof(ushort_values) / sizeof(ushort_values[0]);
constant size_t int_values_length = sizeof(int_values) / sizeof(int_values[0]);
constant size_t uint_values_length = sizeof(uint_values) / sizeof(uint_values[0]);

#ifdef cl_khr_int64
constant long long_values[6] = { 0, 1, LONG_MIN, LONG_MAX, LONG_MIN / 2, LONG_MAX / 2 };
constant ulong ulong_values[6] = { 0, 1, 0, ULONG_MAX, 0 / 2, ULONG_MAX / 2 };

constant size_t long_values_length = sizeof(long_values) / sizeof(long_values[0]);
constant size_t ulong_values_length = sizeof(ulong_values) / sizeof(ulong_values[0]);

#endif

#ifdef cl_khr_fp64
constant float float_sat_offsets[16] =
{
   0.0f, (float)CHAR_MAX, (float)CHAR_MIN, (float)UCHAR_MAX, (float)SHRT_MIN, (float)SHRT_MAX, (float)USHRT_MAX, (float)INT_MAX,
   (float)INT_MIN, (float)UINT_MAX, (float)LONG_MAX, (float)LONG_MIN, (float)ULONG_MAX, 0.0f, 1.0e15f, -1.0e15f
};
#else
constant float float_sat_offsets[13] =
{
   0.0f, (float)CHAR_MAX, (float)CHAR_MIN, (float)UCHAR_MAX, (float)SHRT_MIN, (float)SHRT_MAX, (float)USHRT_MAX, (float)INT_MAX,
   (float)INT_MIN, (float)UINT_MAX, 0.0f, 1.0e15f, -1.0e15f
};
#endif

constant float float_values            [17] = { -2.0f, -1.75f, -1.5f, -1.25f, -1.0f, -0.75f, -0.5f, -0.25f, 0.0f, 0.25f, 0.5f, 0.75f, 1.0f, 1.25f, 1.5f, 1.75f, 2.0f };
constant int float_rounded_values    [17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant int float_rounded_values_rtz[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant int float_rounded_values_rte[17] = { -2     , -2      , -2     , -1      , -1     , -1      ,  0     ,  0      , 0     , 0      , 0     , 1      , 1     , 1      , 2     , 2      , 2      };
constant int float_rounded_values_rtp[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 1      , 1     , 1      , 1     , 2      , 2     , 2      , 2      };
constant int float_rounded_values_rtn[17] = { -2     , -2      , -2     , -2      , -1     , -1      , -1     , -1      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };

constant size_t float_values_length = sizeof(float_values) / sizeof(float_values[0]);


#ifdef cl_khr_fp64

#ifdef cl_khr_fp64
constant double double_sat_offsets[16] =
{
   0.0, (double)CHAR_MAX, (double)CHAR_MIN, (double)UCHAR_MAX, (double)SHRT_MIN, (double)SHRT_MAX, (double)USHRT_MAX, (double)INT_MAX,
   (double)INT_MIN, (double)UINT_MAX, (double)LONG_MAX, (double)LONG_MIN, (double)ULONG_MAX, 0.0, 1.0e15, -1.0e15
};
#else
constant double double_sat_offsets[13] =
{
   0.0, (double)CHAR_MAX, (double)CHAR_MIN, (double)UCHAR_MAX, (double)SHRT_MIN, (double)SHRT_MAX, (double)USHRT_MAX, (double)INT_MAX,
   (double)INT_MIN, (double)UINT_MAX, 0.0, 1.0e15, -1.0e15
};
#endif

constant double double_values            [17] = { -2.0, -1.75, -1.5, -1.25, -1.0, -0.75, -0.5, -0.25, 0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0 };
constant long double_rounded_values    [17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant long double_rounded_values_rtz[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };
constant long double_rounded_values_rte[17] = { -2     , -2      , -2     , -1      , -1     , -1      ,  0     ,  0      , 0     , 0      , 0     , 1      , 1     , 1      , 2     , 2      , 2      };
constant long double_rounded_values_rtp[17] = { -2     , -1      , -1     , -1      , -1     ,  0      ,  0     ,  0      , 0     , 1      , 1     , 1      , 1     , 2      , 2     , 2      , 2      };
constant long double_rounded_values_rtn[17] = { -2     , -2      , -2     , -2      , -1     , -1      , -1     , -1      , 0     , 0      , 0     , 0      , 1     , 1      , 1     , 1      , 2      };

constant size_t double_values_length = sizeof(double_values) / sizeof(double_values[0]);


#endif

_CL_NOINLINE
void compare_char_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_char_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_char_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_char_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_char_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_char_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_char_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_char_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_char_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_char_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const char* expected, const char* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_uchar_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uchar_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uchar_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uchar_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uchar_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uchar_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_uchar_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_uchar_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_uchar_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_uchar_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const uchar* expected, const uchar* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.2hhx actual: %#.2hhx\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_short_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_short_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_short_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_short_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_short_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_short_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_short_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_short_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_short_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_short_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const short* expected, const short* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_ushort_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_ushort_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_ushort_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_ushort_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_ushort_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_ushort_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ushort_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ushort_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_ushort_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_ushort_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const ushort* expected, const ushort* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.4hx actual: %#.4hx\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_int_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_int_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_int_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_int_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_int_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_int_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_int_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_int_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_int_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_int_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const int* expected, const int* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_uint_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uint_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uint_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uint_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uint_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_uint_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_uint_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_uint_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_uint_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_uint_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const uint* expected, const uint* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.8x actual: %#.8x\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_long_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const long* expected, const long* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_ulong_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const ulong* expected, const ulong* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %#.16llx actual: %#.16llx\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#endif

_CL_NOINLINE
void compare_float_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_float_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_float_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_float_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_float_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

_CL_NOINLINE
void compare_float_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_float_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_float_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

_CL_NOINLINE
void compare_float_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_float_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const float* expected, const float* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %.8g actual: %.8g\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_char(string name, size_t sample, constant char* original_scalar, const char* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (char)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_uchar(string name, size_t sample, constant uchar* original_scalar, const uchar* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.2hhx expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (uchar)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_short(string name, size_t sample, constant short* original_scalar, const short* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (short)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_ushort(string name, size_t sample, constant ushort* original_scalar, const ushort* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.4hx expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (ushort)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_int(string name, size_t sample, constant int* original_scalar, const int* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (int)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_uint(string name, size_t sample, constant uint* original_scalar, const uint* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.8x expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (uint)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_double_elements_long(string name, size_t sample, constant long* original_scalar, const long* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (long)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#endif

#ifdef cl_khr_fp64

#ifdef cl_khr_int64

_CL_NOINLINE
void compare_double_elements_ulong(string name, size_t sample, constant ulong* original_scalar, const ulong* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %#.16llx expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (ulong)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_float(string name, size_t sample, constant float* original_scalar, const float* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.8g expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (float)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

#ifdef cl_khr_fp64

_CL_NOINLINE
void compare_double_elements_double(string name, size_t sample, constant double* original_scalar, const double* original_array, const double* expected, const double* actual, size_t n)
{
  for (size_t i = 0; i < n; ++i) {
    if (expected[i] != actual[i]) {
      printf("FAIL: %s - sample#: %u element#: %u original: %.17g expected: %.17g actual: %.17g\n",
        name, (uint)sample, (uint)i, (double)(original_scalar ? *original_scalar : original_array[i]), expected[i], actual[i]);
    }
  }
}

#endif

kernel void test_convert_type_16()
{
  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(CHAR_MIN > CHAR_MIN) ? (char)CHAR_MIN : CHAR_MIN;
    const char max_expected = (char)(CHAR_MAX < CHAR_MAX) ? (char)CHAR_MAX : CHAR_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)char_values[i]));
    actual.value = convert_char16((char16)char_values[i]);
    compare_char_elements_char("convert_char16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((char16)char_values[i]);
    compare_char_elements_char("convert_char16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (char)(UCHAR_MAX < CHAR_MAX) ? (char)UCHAR_MAX : CHAR_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)char_values[i]));
    actual.value = convert_uchar16((char16)char_values[i]);
    compare_uchar_elements_char("convert_uchar16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((char16)char_values[i]);
    compare_uchar_elements_char("convert_uchar16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(SHRT_MIN > CHAR_MIN) ? (char)SHRT_MIN : CHAR_MIN;
    const char max_expected = (char)(SHRT_MAX < CHAR_MAX) ? (char)SHRT_MAX : CHAR_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)char_values[i]));
    actual.value = convert_short16((char16)char_values[i]);
    compare_short_elements_char("convert_short16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((char16)char_values[i]);
    compare_short_elements_char("convert_short16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (char)(USHRT_MAX < CHAR_MAX) ? (char)USHRT_MAX : CHAR_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)char_values[i]));
    actual.value = convert_ushort16((char16)char_values[i]);
    compare_ushort_elements_char("convert_ushort16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((char16)char_values[i]);
    compare_ushort_elements_char("convert_ushort16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(INT_MIN > CHAR_MIN) ? (char)INT_MIN : CHAR_MIN;
    const char max_expected = (char)(INT_MAX < CHAR_MAX) ? (char)INT_MAX : CHAR_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)char_values[i]));
    actual.value = convert_int16((char16)char_values[i]);
    compare_int_elements_char("convert_int16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((char16)char_values[i]);
    compare_int_elements_char("convert_int16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (char)(UINT_MAX < CHAR_MAX) ? (char)UINT_MAX : CHAR_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)char_values[i]));
    actual.value = convert_uint16((char16)char_values[i]);
    compare_uint_elements_char("convert_uint16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((char16)char_values[i]);
    compare_uint_elements_char("convert_uint16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

#ifdef cl_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(LONG_MIN > CHAR_MIN) ? (char)LONG_MIN : CHAR_MIN;
    const char max_expected = (char)(LONG_MAX < CHAR_MAX) ? (char)LONG_MAX : CHAR_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)char_values[i]));
    actual.value = convert_long16((char16)char_values[i]);
    compare_long_elements_char("convert_long16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((char16)char_values[i]);
    compare_long_elements_char("convert_long16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < char_values_length; ++i) {
    const char min_expected = (char)(0 > CHAR_MIN) ? (char)0 : CHAR_MIN;
    const char max_expected = (char)(ULONG_MAX < CHAR_MAX) ? (char)ULONG_MAX : CHAR_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)char_values[i]));
    actual.value = convert_ulong16((char16)char_values[i]);
    compare_ulong_elements_char("convert_ulong16(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
    if (char_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (char_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((char16)char_values[i]);
    compare_ulong_elements_char("convert_ulong16_sat(char16)", i, &char_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(CHAR_MIN > 0) ? (uchar)CHAR_MIN : 0;
    const uchar max_expected = (uchar)(CHAR_MAX < UCHAR_MAX) ? (uchar)CHAR_MAX : UCHAR_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)uchar_values[i]));
    actual.value = convert_char16((uchar16)uchar_values[i]);
    compare_char_elements_uchar("convert_char16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((uchar16)uchar_values[i]);
    compare_char_elements_uchar("convert_char16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (uchar)(UCHAR_MAX < UCHAR_MAX) ? (uchar)UCHAR_MAX : UCHAR_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)uchar_values[i]));
    actual.value = convert_uchar16((uchar16)uchar_values[i]);
    compare_uchar_elements_uchar("convert_uchar16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((uchar16)uchar_values[i]);
    compare_uchar_elements_uchar("convert_uchar16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(SHRT_MIN > 0) ? (uchar)SHRT_MIN : 0;
    const uchar max_expected = (uchar)(SHRT_MAX < UCHAR_MAX) ? (uchar)SHRT_MAX : UCHAR_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)uchar_values[i]));
    actual.value = convert_short16((uchar16)uchar_values[i]);
    compare_short_elements_uchar("convert_short16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((uchar16)uchar_values[i]);
    compare_short_elements_uchar("convert_short16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (uchar)(USHRT_MAX < UCHAR_MAX) ? (uchar)USHRT_MAX : UCHAR_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)uchar_values[i]));
    actual.value = convert_ushort16((uchar16)uchar_values[i]);
    compare_ushort_elements_uchar("convert_ushort16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((uchar16)uchar_values[i]);
    compare_ushort_elements_uchar("convert_ushort16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(INT_MIN > 0) ? (uchar)INT_MIN : 0;
    const uchar max_expected = (uchar)(INT_MAX < UCHAR_MAX) ? (uchar)INT_MAX : UCHAR_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)uchar_values[i]));
    actual.value = convert_int16((uchar16)uchar_values[i]);
    compare_int_elements_uchar("convert_int16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((uchar16)uchar_values[i]);
    compare_int_elements_uchar("convert_int16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (uchar)(UINT_MAX < UCHAR_MAX) ? (uchar)UINT_MAX : UCHAR_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)uchar_values[i]));
    actual.value = convert_uint16((uchar16)uchar_values[i]);
    compare_uint_elements_uchar("convert_uint16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((uchar16)uchar_values[i]);
    compare_uint_elements_uchar("convert_uint16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

#ifdef cl_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(LONG_MIN > 0) ? (uchar)LONG_MIN : 0;
    const uchar max_expected = (uchar)(LONG_MAX < UCHAR_MAX) ? (uchar)LONG_MAX : UCHAR_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)uchar_values[i]));
    actual.value = convert_long16((uchar16)uchar_values[i]);
    compare_long_elements_uchar("convert_long16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((uchar16)uchar_values[i]);
    compare_long_elements_uchar("convert_long16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < uchar_values_length; ++i) {
    const uchar min_expected = (uchar)(0 > 0) ? (uchar)0 : 0;
    const uchar max_expected = (uchar)(ULONG_MAX < UCHAR_MAX) ? (uchar)ULONG_MAX : UCHAR_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)uchar_values[i]));
    actual.value = convert_ulong16((uchar16)uchar_values[i]);
    compare_ulong_elements_uchar("convert_ulong16(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
    if (uchar_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (uchar_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((uchar16)uchar_values[i]);
    compare_ulong_elements_uchar("convert_ulong16_sat(uchar16)", i, &uchar_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(CHAR_MIN > SHRT_MIN) ? (short)CHAR_MIN : SHRT_MIN;
    const short max_expected = (short)(CHAR_MAX < SHRT_MAX) ? (short)CHAR_MAX : SHRT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)short_values[i]));
    actual.value = convert_char16((short16)short_values[i]);
    compare_char_elements_short("convert_char16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((short16)short_values[i]);
    compare_char_elements_short("convert_char16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (short)(UCHAR_MAX < SHRT_MAX) ? (short)UCHAR_MAX : SHRT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)short_values[i]));
    actual.value = convert_uchar16((short16)short_values[i]);
    compare_uchar_elements_short("convert_uchar16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((short16)short_values[i]);
    compare_uchar_elements_short("convert_uchar16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(SHRT_MIN > SHRT_MIN) ? (short)SHRT_MIN : SHRT_MIN;
    const short max_expected = (short)(SHRT_MAX < SHRT_MAX) ? (short)SHRT_MAX : SHRT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)short_values[i]));
    actual.value = convert_short16((short16)short_values[i]);
    compare_short_elements_short("convert_short16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((short16)short_values[i]);
    compare_short_elements_short("convert_short16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (short)(USHRT_MAX < SHRT_MAX) ? (short)USHRT_MAX : SHRT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)short_values[i]));
    actual.value = convert_ushort16((short16)short_values[i]);
    compare_ushort_elements_short("convert_ushort16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((short16)short_values[i]);
    compare_ushort_elements_short("convert_ushort16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(INT_MIN > SHRT_MIN) ? (short)INT_MIN : SHRT_MIN;
    const short max_expected = (short)(INT_MAX < SHRT_MAX) ? (short)INT_MAX : SHRT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)short_values[i]));
    actual.value = convert_int16((short16)short_values[i]);
    compare_int_elements_short("convert_int16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((short16)short_values[i]);
    compare_int_elements_short("convert_int16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (short)(UINT_MAX < SHRT_MAX) ? (short)UINT_MAX : SHRT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)short_values[i]));
    actual.value = convert_uint16((short16)short_values[i]);
    compare_uint_elements_short("convert_uint16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((short16)short_values[i]);
    compare_uint_elements_short("convert_uint16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

#ifdef cl_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(LONG_MIN > SHRT_MIN) ? (short)LONG_MIN : SHRT_MIN;
    const short max_expected = (short)(LONG_MAX < SHRT_MAX) ? (short)LONG_MAX : SHRT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)short_values[i]));
    actual.value = convert_long16((short16)short_values[i]);
    compare_long_elements_short("convert_long16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((short16)short_values[i]);
    compare_long_elements_short("convert_long16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < short_values_length; ++i) {
    const short min_expected = (short)(0 > SHRT_MIN) ? (short)0 : SHRT_MIN;
    const short max_expected = (short)(ULONG_MAX < SHRT_MAX) ? (short)ULONG_MAX : SHRT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)short_values[i]));
    actual.value = convert_ulong16((short16)short_values[i]);
    compare_ulong_elements_short("convert_ulong16(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
    if (short_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (short_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((short16)short_values[i]);
    compare_ulong_elements_short("convert_ulong16_sat(short16)", i, &short_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(CHAR_MIN > 0) ? (ushort)CHAR_MIN : 0;
    const ushort max_expected = (ushort)(CHAR_MAX < USHRT_MAX) ? (ushort)CHAR_MAX : USHRT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)ushort_values[i]));
    actual.value = convert_char16((ushort16)ushort_values[i]);
    compare_char_elements_ushort("convert_char16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((ushort16)ushort_values[i]);
    compare_char_elements_ushort("convert_char16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ushort)(UCHAR_MAX < USHRT_MAX) ? (ushort)UCHAR_MAX : USHRT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)ushort_values[i]));
    actual.value = convert_uchar16((ushort16)ushort_values[i]);
    compare_uchar_elements_ushort("convert_uchar16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((ushort16)ushort_values[i]);
    compare_uchar_elements_ushort("convert_uchar16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(SHRT_MIN > 0) ? (ushort)SHRT_MIN : 0;
    const ushort max_expected = (ushort)(SHRT_MAX < USHRT_MAX) ? (ushort)SHRT_MAX : USHRT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)ushort_values[i]));
    actual.value = convert_short16((ushort16)ushort_values[i]);
    compare_short_elements_ushort("convert_short16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((ushort16)ushort_values[i]);
    compare_short_elements_ushort("convert_short16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ushort)(USHRT_MAX < USHRT_MAX) ? (ushort)USHRT_MAX : USHRT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)ushort_values[i]));
    actual.value = convert_ushort16((ushort16)ushort_values[i]);
    compare_ushort_elements_ushort("convert_ushort16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((ushort16)ushort_values[i]);
    compare_ushort_elements_ushort("convert_ushort16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(INT_MIN > 0) ? (ushort)INT_MIN : 0;
    const ushort max_expected = (ushort)(INT_MAX < USHRT_MAX) ? (ushort)INT_MAX : USHRT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)ushort_values[i]));
    actual.value = convert_int16((ushort16)ushort_values[i]);
    compare_int_elements_ushort("convert_int16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((ushort16)ushort_values[i]);
    compare_int_elements_ushort("convert_int16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ushort)(UINT_MAX < USHRT_MAX) ? (ushort)UINT_MAX : USHRT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)ushort_values[i]));
    actual.value = convert_uint16((ushort16)ushort_values[i]);
    compare_uint_elements_ushort("convert_uint16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((ushort16)ushort_values[i]);
    compare_uint_elements_ushort("convert_uint16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

#ifdef cl_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(LONG_MIN > 0) ? (ushort)LONG_MIN : 0;
    const ushort max_expected = (ushort)(LONG_MAX < USHRT_MAX) ? (ushort)LONG_MAX : USHRT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)ushort_values[i]));
    actual.value = convert_long16((ushort16)ushort_values[i]);
    compare_long_elements_ushort("convert_long16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((ushort16)ushort_values[i]);
    compare_long_elements_ushort("convert_long16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ushort_values_length; ++i) {
    const ushort min_expected = (ushort)(0 > 0) ? (ushort)0 : 0;
    const ushort max_expected = (ushort)(ULONG_MAX < USHRT_MAX) ? (ushort)ULONG_MAX : USHRT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)ushort_values[i]));
    actual.value = convert_ulong16((ushort16)ushort_values[i]);
    compare_ulong_elements_ushort("convert_ulong16(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
    if (ushort_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (ushort_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((ushort16)ushort_values[i]);
    compare_ulong_elements_ushort("convert_ulong16_sat(ushort16)", i, &ushort_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(CHAR_MIN > INT_MIN) ? (int)CHAR_MIN : INT_MIN;
    const int max_expected = (int)(CHAR_MAX < INT_MAX) ? (int)CHAR_MAX : INT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)int_values[i]));
    actual.value = convert_char16((int16)int_values[i]);
    compare_char_elements_int("convert_char16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((int16)int_values[i]);
    compare_char_elements_int("convert_char16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (int)(UCHAR_MAX < INT_MAX) ? (int)UCHAR_MAX : INT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)int_values[i]));
    actual.value = convert_uchar16((int16)int_values[i]);
    compare_uchar_elements_int("convert_uchar16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((int16)int_values[i]);
    compare_uchar_elements_int("convert_uchar16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(SHRT_MIN > INT_MIN) ? (int)SHRT_MIN : INT_MIN;
    const int max_expected = (int)(SHRT_MAX < INT_MAX) ? (int)SHRT_MAX : INT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)int_values[i]));
    actual.value = convert_short16((int16)int_values[i]);
    compare_short_elements_int("convert_short16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((int16)int_values[i]);
    compare_short_elements_int("convert_short16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (int)(USHRT_MAX < INT_MAX) ? (int)USHRT_MAX : INT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)int_values[i]));
    actual.value = convert_ushort16((int16)int_values[i]);
    compare_ushort_elements_int("convert_ushort16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((int16)int_values[i]);
    compare_ushort_elements_int("convert_ushort16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(INT_MIN > INT_MIN) ? (int)INT_MIN : INT_MIN;
    const int max_expected = (int)(INT_MAX < INT_MAX) ? (int)INT_MAX : INT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)int_values[i]));
    actual.value = convert_int16((int16)int_values[i]);
    compare_int_elements_int("convert_int16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((int16)int_values[i]);
    compare_int_elements_int("convert_int16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (int)(UINT_MAX < INT_MAX) ? (int)UINT_MAX : INT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)int_values[i]));
    actual.value = convert_uint16((int16)int_values[i]);
    compare_uint_elements_int("convert_uint16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((int16)int_values[i]);
    compare_uint_elements_int("convert_uint16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

#ifdef cl_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(LONG_MIN > INT_MIN) ? (int)LONG_MIN : INT_MIN;
    const int max_expected = (int)(LONG_MAX < INT_MAX) ? (int)LONG_MAX : INT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)int_values[i]));
    actual.value = convert_long16((int16)int_values[i]);
    compare_long_elements_int("convert_long16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((int16)int_values[i]);
    compare_long_elements_int("convert_long16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < int_values_length; ++i) {
    const int min_expected = (int)(0 > INT_MIN) ? (int)0 : INT_MIN;
    const int max_expected = (int)(ULONG_MAX < INT_MAX) ? (int)ULONG_MAX : INT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)int_values[i]));
    actual.value = convert_ulong16((int16)int_values[i]);
    compare_ulong_elements_int("convert_ulong16(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
    if (int_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (int_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((int16)int_values[i]);
    compare_ulong_elements_int("convert_ulong16_sat(int16)", i, &int_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(CHAR_MIN > 0) ? (uint)CHAR_MIN : 0;
    const uint max_expected = (uint)(CHAR_MAX < UINT_MAX) ? (uint)CHAR_MAX : UINT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)uint_values[i]));
    actual.value = convert_char16((uint16)uint_values[i]);
    compare_char_elements_uint("convert_char16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((uint16)uint_values[i]);
    compare_char_elements_uint("convert_char16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(0 > 0) ? (uint)0 : 0;
    const uint max_expected = (uint)(UCHAR_MAX < UINT_MAX) ? (uint)UCHAR_MAX : UINT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)uint_values[i]));
    actual.value = convert_uchar16((uint16)uint_values[i]);
    compare_uchar_elements_uint("convert_uchar16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((uint16)uint_values[i]);
    compare_uchar_elements_uint("convert_uchar16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(SHRT_MIN > 0) ? (uint)SHRT_MIN : 0;
    const uint max_expected = (uint)(SHRT_MAX < UINT_MAX) ? (uint)SHRT_MAX : UINT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)uint_values[i]));
    actual.value = convert_short16((uint16)uint_values[i]);
    compare_short_elements_uint("convert_short16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((uint16)uint_values[i]);
    compare_short_elements_uint("convert_short16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(0 > 0) ? (uint)0 : 0;
    const uint max_expected = (uint)(USHRT_MAX < UINT_MAX) ? (uint)USHRT_MAX : UINT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)uint_values[i]));
    actual.value = convert_ushort16((uint16)uint_values[i]);
    compare_ushort_elements_uint("convert_ushort16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((uint16)uint_values[i]);
    compare_ushort_elements_uint("convert_ushort16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(INT_MIN > 0) ? (uint)INT_MIN : 0;
    const uint max_expected = (uint)(INT_MAX < UINT_MAX) ? (uint)INT_MAX : UINT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)uint_values[i]));
    actual.value = convert_int16((uint16)uint_values[i]);
    compare_int_elements_uint("convert_int16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((uint16)uint_values[i]);
    compare_int_elements_uint("convert_int16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(0 > 0) ? (uint)0 : 0;
    const uint max_expected = (uint)(UINT_MAX < UINT_MAX) ? (uint)UINT_MAX : UINT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)uint_values[i]));
    actual.value = convert_uint16((uint16)uint_values[i]);
    compare_uint_elements_uint("convert_uint16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((uint16)uint_values[i]);
    compare_uint_elements_uint("convert_uint16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

#ifdef cl_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(LONG_MIN > 0) ? (uint)LONG_MIN : 0;
    const uint max_expected = (uint)(LONG_MAX < UINT_MAX) ? (uint)LONG_MAX : UINT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)uint_values[i]));
    actual.value = convert_long16((uint16)uint_values[i]);
    compare_long_elements_uint("convert_long16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((uint16)uint_values[i]);
    compare_long_elements_uint("convert_long16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < uint_values_length; ++i) {
    const uint min_expected = (uint)(0 > 0) ? (uint)0 : 0;
    const uint max_expected = (uint)(ULONG_MAX < UINT_MAX) ? (uint)ULONG_MAX : UINT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)uint_values[i]));
    actual.value = convert_ulong16((uint16)uint_values[i]);
    compare_ulong_elements_uint("convert_ulong16(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
    if (uint_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (uint_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((uint16)uint_values[i]);
    compare_ulong_elements_uint("convert_ulong16_sat(uint16)", i, &uint_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(CHAR_MIN > LONG_MIN) ? (long)CHAR_MIN : LONG_MIN;
    const long max_expected = (long)(CHAR_MAX < LONG_MAX) ? (long)CHAR_MAX : LONG_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)long_values[i]));
    actual.value = convert_char16((long16)long_values[i]);
    compare_char_elements_long("convert_char16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((long16)long_values[i]);
    compare_char_elements_long("convert_char16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (long)(UCHAR_MAX < LONG_MAX) ? (long)UCHAR_MAX : LONG_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)long_values[i]));
    actual.value = convert_uchar16((long16)long_values[i]);
    compare_uchar_elements_long("convert_uchar16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((long16)long_values[i]);
    compare_uchar_elements_long("convert_uchar16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(SHRT_MIN > LONG_MIN) ? (long)SHRT_MIN : LONG_MIN;
    const long max_expected = (long)(SHRT_MAX < LONG_MAX) ? (long)SHRT_MAX : LONG_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)long_values[i]));
    actual.value = convert_short16((long16)long_values[i]);
    compare_short_elements_long("convert_short16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((long16)long_values[i]);
    compare_short_elements_long("convert_short16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (long)(USHRT_MAX < LONG_MAX) ? (long)USHRT_MAX : LONG_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)long_values[i]));
    actual.value = convert_ushort16((long16)long_values[i]);
    compare_ushort_elements_long("convert_ushort16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((long16)long_values[i]);
    compare_ushort_elements_long("convert_ushort16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(INT_MIN > LONG_MIN) ? (long)INT_MIN : LONG_MIN;
    const long max_expected = (long)(INT_MAX < LONG_MAX) ? (long)INT_MAX : LONG_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)long_values[i]));
    actual.value = convert_int16((long16)long_values[i]);
    compare_int_elements_long("convert_int16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((long16)long_values[i]);
    compare_int_elements_long("convert_int16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (long)(UINT_MAX < LONG_MAX) ? (long)UINT_MAX : LONG_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)long_values[i]));
    actual.value = convert_uint16((long16)long_values[i]);
    compare_uint_elements_long("convert_uint16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((long16)long_values[i]);
    compare_uint_elements_long("convert_uint16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(LONG_MIN > LONG_MIN) ? (long)LONG_MIN : LONG_MIN;
    const long max_expected = (long)(LONG_MAX < LONG_MAX) ? (long)LONG_MAX : LONG_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)long_values[i]));
    actual.value = convert_long16((long16)long_values[i]);
    compare_long_elements_long("convert_long16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((long16)long_values[i]);
    compare_long_elements_long("convert_long16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < long_values_length; ++i) {
    const long min_expected = (long)(0 > LONG_MIN) ? (long)0 : LONG_MIN;
    const long max_expected = (long)(ULONG_MAX < LONG_MAX) ? (long)ULONG_MAX : LONG_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)long_values[i]));
    actual.value = convert_ulong16((long16)long_values[i]);
    compare_ulong_elements_long("convert_ulong16(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
    if (long_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (long_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((long16)long_values[i]);
    compare_ulong_elements_long("convert_ulong16_sat(long16)", i, &long_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(CHAR_MIN > 0) ? (ulong)CHAR_MIN : 0;
    const ulong max_expected = (ulong)(CHAR_MAX < ULONG_MAX) ? (ulong)CHAR_MAX : ULONG_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)ulong_values[i]));
    actual.value = convert_char16((ulong16)ulong_values[i]);
    compare_char_elements_ulong("convert_char16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((ulong16)ulong_values[i]);
    compare_char_elements_ulong("convert_char16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ulong)(UCHAR_MAX < ULONG_MAX) ? (ulong)UCHAR_MAX : ULONG_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)ulong_values[i]));
    actual.value = convert_uchar16((ulong16)ulong_values[i]);
    compare_uchar_elements_ulong("convert_uchar16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((ulong16)ulong_values[i]);
    compare_uchar_elements_ulong("convert_uchar16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(SHRT_MIN > 0) ? (ulong)SHRT_MIN : 0;
    const ulong max_expected = (ulong)(SHRT_MAX < ULONG_MAX) ? (ulong)SHRT_MAX : ULONG_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)ulong_values[i]));
    actual.value = convert_short16((ulong16)ulong_values[i]);
    compare_short_elements_ulong("convert_short16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((ulong16)ulong_values[i]);
    compare_short_elements_ulong("convert_short16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ulong)(USHRT_MAX < ULONG_MAX) ? (ulong)USHRT_MAX : ULONG_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)ulong_values[i]));
    actual.value = convert_ushort16((ulong16)ulong_values[i]);
    compare_ushort_elements_ulong("convert_ushort16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((ulong16)ulong_values[i]);
    compare_ushort_elements_ulong("convert_ushort16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(INT_MIN > 0) ? (ulong)INT_MIN : 0;
    const ulong max_expected = (ulong)(INT_MAX < ULONG_MAX) ? (ulong)INT_MAX : ULONG_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)ulong_values[i]));
    actual.value = convert_int16((ulong16)ulong_values[i]);
    compare_int_elements_ulong("convert_int16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((ulong16)ulong_values[i]);
    compare_int_elements_ulong("convert_int16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ulong)(UINT_MAX < ULONG_MAX) ? (ulong)UINT_MAX : ULONG_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)ulong_values[i]));
    actual.value = convert_uint16((ulong16)ulong_values[i]);
    compare_uint_elements_ulong("convert_uint16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((ulong16)ulong_values[i]);
    compare_uint_elements_ulong("convert_uint16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(LONG_MIN > 0) ? (ulong)LONG_MIN : 0;
    const ulong max_expected = (ulong)(LONG_MAX < ULONG_MAX) ? (ulong)LONG_MAX : ULONG_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)ulong_values[i]));
    actual.value = convert_long16((ulong16)ulong_values[i]);
    compare_long_elements_ulong("convert_long16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((ulong16)ulong_values[i]);
    compare_long_elements_ulong("convert_long16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < ulong_values_length; ++i) {
    const ulong min_expected = (ulong)(0 > 0) ? (ulong)0 : 0;
    const ulong max_expected = (ulong)(ULONG_MAX < ULONG_MAX) ? (ulong)ULONG_MAX : ULONG_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)ulong_values[i]));
    actual.value = convert_ulong16((ulong16)ulong_values[i]);
    compare_ulong_elements_ulong("convert_ulong16(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
    if (ulong_values[i] < min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (ulong_values[i] > max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((ulong16)ulong_values[i]);
    compare_ulong_elements_ulong("convert_ulong16_sat(ulong16)", i, &ulong_values[i], 0, expected.raw, actual.raw, 16);
  }

#endif

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const char min_expected = (char)(CHAR_MIN > -FLT_MAX) ? CHAR_MIN : (char)-FLT_MAX;
    const char max_expected = (char)(CHAR_MAX < FLT_MAX) ? CHAR_MAX : (char)FLT_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)float_rounded_values[i]));
    actual.value = convert_char16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_float("convert_char16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((float16)sat_input);
    compare_char_elements_float("convert_char16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rte[i]));
    actual.value = convert_char16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_float("convert_char16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rte((float16)sat_input);
    compare_char_elements_float("convert_char16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rtz[i]));
    actual.value = convert_char16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_float("convert_char16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtz((float16)sat_input);
    compare_char_elements_float("convert_char16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rtp[i]));
    actual.value = convert_char16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_float("convert_char16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtp((float16)sat_input);
    compare_char_elements_float("convert_char16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)float_rounded_values_rtn[i]));
    actual.value = convert_char16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_float("convert_char16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtn((float16)sat_input);
    compare_char_elements_float("convert_char16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const uchar min_expected = (uchar)(0 > -FLT_MAX) ? 0 : (uchar)-FLT_MAX;
    const uchar max_expected = (uchar)(UCHAR_MAX < FLT_MAX) ? UCHAR_MAX : (uchar)FLT_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)float_rounded_values[i]));
    actual.value = convert_uchar16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_float("convert_uchar16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((float16)sat_input);
    compare_uchar_elements_float("convert_uchar16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rte[i]));
    actual.value = convert_uchar16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_float("convert_uchar16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rte((float16)sat_input);
    compare_uchar_elements_float("convert_uchar16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rtz[i]));
    actual.value = convert_uchar16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_float("convert_uchar16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtz((float16)sat_input);
    compare_uchar_elements_float("convert_uchar16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rtp[i]));
    actual.value = convert_uchar16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_float("convert_uchar16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtp((float16)sat_input);
    compare_uchar_elements_float("convert_uchar16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)float_rounded_values_rtn[i]));
    actual.value = convert_uchar16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_float("convert_uchar16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtn((float16)sat_input);
    compare_uchar_elements_float("convert_uchar16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const short min_expected = (short)(SHRT_MIN > -FLT_MAX) ? SHRT_MIN : (short)-FLT_MAX;
    const short max_expected = (short)(SHRT_MAX < FLT_MAX) ? SHRT_MAX : (short)FLT_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)float_rounded_values[i]));
    actual.value = convert_short16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_float("convert_short16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((float16)sat_input);
    compare_short_elements_float("convert_short16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rte[i]));
    actual.value = convert_short16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_float("convert_short16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rte((float16)sat_input);
    compare_short_elements_float("convert_short16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rtz[i]));
    actual.value = convert_short16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_float("convert_short16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtz((float16)sat_input);
    compare_short_elements_float("convert_short16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rtp[i]));
    actual.value = convert_short16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_float("convert_short16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtp((float16)sat_input);
    compare_short_elements_float("convert_short16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)float_rounded_values_rtn[i]));
    actual.value = convert_short16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_float("convert_short16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtn((float16)sat_input);
    compare_short_elements_float("convert_short16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const ushort min_expected = (ushort)(0 > -FLT_MAX) ? 0 : (ushort)-FLT_MAX;
    const ushort max_expected = (ushort)(USHRT_MAX < FLT_MAX) ? USHRT_MAX : (ushort)FLT_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)float_rounded_values[i]));
    actual.value = convert_ushort16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_float("convert_ushort16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((float16)sat_input);
    compare_ushort_elements_float("convert_ushort16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rte[i]));
    actual.value = convert_ushort16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_float("convert_ushort16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rte((float16)sat_input);
    compare_ushort_elements_float("convert_ushort16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rtz[i]));
    actual.value = convert_ushort16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_float("convert_ushort16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtz((float16)sat_input);
    compare_ushort_elements_float("convert_ushort16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rtp[i]));
    actual.value = convert_ushort16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_float("convert_ushort16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtp((float16)sat_input);
    compare_ushort_elements_float("convert_ushort16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)float_rounded_values_rtn[i]));
    actual.value = convert_ushort16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_float("convert_ushort16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtn((float16)sat_input);
    compare_ushort_elements_float("convert_ushort16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const int min_expected = (int)(INT_MIN > -FLT_MAX) ? INT_MIN : (int)-FLT_MAX;
    const int max_expected = (int)(INT_MAX < FLT_MAX) ? INT_MAX : (int)FLT_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)float_rounded_values[i]));
    actual.value = convert_int16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_float("convert_int16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((float16)sat_input);
    compare_int_elements_float("convert_int16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rte[i]));
    actual.value = convert_int16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_float("convert_int16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rte((float16)sat_input);
    compare_int_elements_float("convert_int16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rtz[i]));
    actual.value = convert_int16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_float("convert_int16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtz((float16)sat_input);
    compare_int_elements_float("convert_int16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rtp[i]));
    actual.value = convert_int16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_float("convert_int16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtp((float16)sat_input);
    compare_int_elements_float("convert_int16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)float_rounded_values_rtn[i]));
    actual.value = convert_int16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_float("convert_int16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtn((float16)sat_input);
    compare_int_elements_float("convert_int16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const uint min_expected = (uint)(0 > -FLT_MAX) ? 0 : (uint)-FLT_MAX;
    const uint max_expected = (uint)(UINT_MAX < FLT_MAX) ? UINT_MAX : (uint)FLT_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)float_rounded_values[i]));
    actual.value = convert_uint16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_float("convert_uint16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((float16)sat_input);
    compare_uint_elements_float("convert_uint16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rte[i]));
    actual.value = convert_uint16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_float("convert_uint16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rte((float16)sat_input);
    compare_uint_elements_float("convert_uint16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rtz[i]));
    actual.value = convert_uint16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_float("convert_uint16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtz((float16)sat_input);
    compare_uint_elements_float("convert_uint16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rtp[i]));
    actual.value = convert_uint16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_float("convert_uint16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtp((float16)sat_input);
    compare_uint_elements_float("convert_uint16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)float_rounded_values_rtn[i]));
    actual.value = convert_uint16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_float("convert_uint16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtn((float16)sat_input);
    compare_uint_elements_float("convert_uint16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#ifdef cl_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const long min_expected = (long)(LONG_MIN > -FLT_MAX) ? LONG_MIN : (long)-FLT_MAX;
    const long max_expected = (long)(LONG_MAX < FLT_MAX) ? LONG_MAX : (long)FLT_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)float_rounded_values[i]));
    actual.value = convert_long16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_float("convert_long16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((float16)sat_input);
    compare_long_elements_float("convert_long16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rte[i]));
    actual.value = convert_long16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_float("convert_long16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rte((float16)sat_input);
    compare_long_elements_float("convert_long16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rtz[i]));
    actual.value = convert_long16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_float("convert_long16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtz((float16)sat_input);
    compare_long_elements_float("convert_long16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rtp[i]));
    actual.value = convert_long16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_float("convert_long16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtp((float16)sat_input);
    compare_long_elements_float("convert_long16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)float_rounded_values_rtn[i]));
    actual.value = convert_long16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_float("convert_long16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtn((float16)sat_input);
    compare_long_elements_float("convert_long16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

  for (size_t i = 0; i < float_values_length; ++i) {
    const float sat_input = (float_values[i] + float_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const ulong min_expected = (ulong)(0 > -FLT_MAX) ? 0 : (ulong)-FLT_MAX;
    const ulong max_expected = (ulong)(ULONG_MAX < FLT_MAX) ? ULONG_MAX : (ulong)FLT_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)float_rounded_values[i]));
    actual.value = convert_ulong16((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = float_rounded_values[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_float("convert_ulong16(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((float16)sat_input);
    compare_ulong_elements_float("convert_ulong16_sat(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rte[i]));
    actual.value = convert_ulong16_rte((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = float_rounded_values_rte[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_float("convert_ulong16_rte(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rte(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rte((float16)sat_input);
    compare_ulong_elements_float("convert_ulong16_sat_rte(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rtz[i]));
    actual.value = convert_ulong16_rtz((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = float_rounded_values_rtz[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_float("convert_ulong16_rtz(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtz(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtz((float16)sat_input);
    compare_ulong_elements_float("convert_ulong16_sat_rtz(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rtp[i]));
    actual.value = convert_ulong16_rtp((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = float_rounded_values_rtp[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_float("convert_ulong16_rtp(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtp(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtp((float16)sat_input);
    compare_ulong_elements_float("convert_ulong16_sat_rtp(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)float_rounded_values_rtn[i]));
    actual.value = convert_ulong16_rtn((float16)float_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = float_rounded_values_rtn[i] < (float)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_float("convert_ulong16_rtn(float16)", i, &float_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtn(sat_input);
    if (sat_input <= (float)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (float)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtn((float16)sat_input);
    compare_ulong_elements_float("convert_ulong16_sat_rtn(float16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const char min_expected = (char)(CHAR_MIN > -DBL_MAX) ? CHAR_MIN : (char)-DBL_MAX;
    const char max_expected = (char)(CHAR_MAX < DBL_MAX) ? CHAR_MAX : (char)DBL_MAX;
    union { char16 value; char raw[16]; } expected, actual;
    expected.value = ((char16)((char)double_rounded_values[i]));
    actual.value = convert_char16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_double("convert_char16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat((double16)sat_input);
    compare_char_elements_double("convert_char16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rte[i]));
    actual.value = convert_char16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_double("convert_char16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rte((double16)sat_input);
    compare_char_elements_double("convert_char16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rtz[i]));
    actual.value = convert_char16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_double("convert_char16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtz((double16)sat_input);
    compare_char_elements_double("convert_char16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rtp[i]));
    actual.value = convert_char16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_double("convert_char16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtp((double16)sat_input);
    compare_char_elements_double("convert_char16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((char16)((char)double_rounded_values_rtn[i]));
    actual.value = convert_char16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (char)((char)0 - (char)1) >= (char)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (char)0;
        actual.raw[n] = (char)0;
      }
    }
    compare_char_elements_double("convert_char16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (char16)convert_char_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (char16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (char16)max_expected;
    }
    actual.value = convert_char16_sat_rtn((double16)sat_input);
    compare_char_elements_double("convert_char16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const uchar min_expected = (uchar)(0 > -DBL_MAX) ? 0 : (uchar)-DBL_MAX;
    const uchar max_expected = (uchar)(UCHAR_MAX < DBL_MAX) ? UCHAR_MAX : (uchar)DBL_MAX;
    union { uchar16 value; uchar raw[16]; } expected, actual;
    expected.value = ((uchar16)((uchar)double_rounded_values[i]));
    actual.value = convert_uchar16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_double("convert_uchar16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat((double16)sat_input);
    compare_uchar_elements_double("convert_uchar16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rte[i]));
    actual.value = convert_uchar16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_double("convert_uchar16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rte((double16)sat_input);
    compare_uchar_elements_double("convert_uchar16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rtz[i]));
    actual.value = convert_uchar16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_double("convert_uchar16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtz((double16)sat_input);
    compare_uchar_elements_double("convert_uchar16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rtp[i]));
    actual.value = convert_uchar16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_double("convert_uchar16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtp((double16)sat_input);
    compare_uchar_elements_double("convert_uchar16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uchar16)((uchar)double_rounded_values_rtn[i]));
    actual.value = convert_uchar16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uchar)((uchar)0 - (uchar)1) >= (uchar)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uchar)0;
        actual.raw[n] = (uchar)0;
      }
    }
    compare_uchar_elements_double("convert_uchar16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uchar16)convert_uchar_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uchar16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uchar16)max_expected;
    }
    actual.value = convert_uchar16_sat_rtn((double16)sat_input);
    compare_uchar_elements_double("convert_uchar16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const short min_expected = (short)(SHRT_MIN > -DBL_MAX) ? SHRT_MIN : (short)-DBL_MAX;
    const short max_expected = (short)(SHRT_MAX < DBL_MAX) ? SHRT_MAX : (short)DBL_MAX;
    union { short16 value; short raw[16]; } expected, actual;
    expected.value = ((short16)((short)double_rounded_values[i]));
    actual.value = convert_short16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_double("convert_short16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat((double16)sat_input);
    compare_short_elements_double("convert_short16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rte[i]));
    actual.value = convert_short16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_double("convert_short16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rte((double16)sat_input);
    compare_short_elements_double("convert_short16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rtz[i]));
    actual.value = convert_short16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_double("convert_short16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtz((double16)sat_input);
    compare_short_elements_double("convert_short16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rtp[i]));
    actual.value = convert_short16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_double("convert_short16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtp((double16)sat_input);
    compare_short_elements_double("convert_short16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((short16)((short)double_rounded_values_rtn[i]));
    actual.value = convert_short16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (short)((short)0 - (short)1) >= (short)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (short)0;
        actual.raw[n] = (short)0;
      }
    }
    compare_short_elements_double("convert_short16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (short16)convert_short_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (short16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (short16)max_expected;
    }
    actual.value = convert_short16_sat_rtn((double16)sat_input);
    compare_short_elements_double("convert_short16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const ushort min_expected = (ushort)(0 > -DBL_MAX) ? 0 : (ushort)-DBL_MAX;
    const ushort max_expected = (ushort)(USHRT_MAX < DBL_MAX) ? USHRT_MAX : (ushort)DBL_MAX;
    union { ushort16 value; ushort raw[16]; } expected, actual;
    expected.value = ((ushort16)((ushort)double_rounded_values[i]));
    actual.value = convert_ushort16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_double("convert_ushort16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat((double16)sat_input);
    compare_ushort_elements_double("convert_ushort16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rte[i]));
    actual.value = convert_ushort16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_double("convert_ushort16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rte((double16)sat_input);
    compare_ushort_elements_double("convert_ushort16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rtz[i]));
    actual.value = convert_ushort16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_double("convert_ushort16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtz((double16)sat_input);
    compare_ushort_elements_double("convert_ushort16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rtp[i]));
    actual.value = convert_ushort16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_double("convert_ushort16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtp((double16)sat_input);
    compare_ushort_elements_double("convert_ushort16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ushort16)((ushort)double_rounded_values_rtn[i]));
    actual.value = convert_ushort16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ushort)((ushort)0 - (ushort)1) >= (ushort)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ushort)0;
        actual.raw[n] = (ushort)0;
      }
    }
    compare_ushort_elements_double("convert_ushort16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ushort16)convert_ushort_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ushort16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ushort16)max_expected;
    }
    actual.value = convert_ushort16_sat_rtn((double16)sat_input);
    compare_ushort_elements_double("convert_ushort16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const int min_expected = (int)(INT_MIN > -DBL_MAX) ? INT_MIN : (int)-DBL_MAX;
    const int max_expected = (int)(INT_MAX < DBL_MAX) ? INT_MAX : (int)DBL_MAX;
    union { int16 value; int raw[16]; } expected, actual;
    expected.value = ((int16)((int)double_rounded_values[i]));
    actual.value = convert_int16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_double("convert_int16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat((double16)sat_input);
    compare_int_elements_double("convert_int16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rte[i]));
    actual.value = convert_int16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_double("convert_int16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rte((double16)sat_input);
    compare_int_elements_double("convert_int16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rtz[i]));
    actual.value = convert_int16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_double("convert_int16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtz((double16)sat_input);
    compare_int_elements_double("convert_int16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rtp[i]));
    actual.value = convert_int16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_double("convert_int16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtp((double16)sat_input);
    compare_int_elements_double("convert_int16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((int16)((int)double_rounded_values_rtn[i]));
    actual.value = convert_int16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (int)((int)0 - (int)1) >= (int)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (int)0;
        actual.raw[n] = (int)0;
      }
    }
    compare_int_elements_double("convert_int16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (int16)convert_int_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (int16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (int16)max_expected;
    }
    actual.value = convert_int16_sat_rtn((double16)sat_input);
    compare_int_elements_double("convert_int16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const uint min_expected = (uint)(0 > -DBL_MAX) ? 0 : (uint)-DBL_MAX;
    const uint max_expected = (uint)(UINT_MAX < DBL_MAX) ? UINT_MAX : (uint)DBL_MAX;
    union { uint16 value; uint raw[16]; } expected, actual;
    expected.value = ((uint16)((uint)double_rounded_values[i]));
    actual.value = convert_uint16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_double("convert_uint16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat((double16)sat_input);
    compare_uint_elements_double("convert_uint16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rte[i]));
    actual.value = convert_uint16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_double("convert_uint16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rte((double16)sat_input);
    compare_uint_elements_double("convert_uint16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rtz[i]));
    actual.value = convert_uint16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_double("convert_uint16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtz((double16)sat_input);
    compare_uint_elements_double("convert_uint16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rtp[i]));
    actual.value = convert_uint16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_double("convert_uint16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtp((double16)sat_input);
    compare_uint_elements_double("convert_uint16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((uint16)((uint)double_rounded_values_rtn[i]));
    actual.value = convert_uint16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (uint)((uint)0 - (uint)1) >= (uint)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (uint)0;
        actual.raw[n] = (uint)0;
      }
    }
    compare_uint_elements_double("convert_uint16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (uint16)convert_uint_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (uint16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (uint16)max_expected;
    }
    actual.value = convert_uint16_sat_rtn((double16)sat_input);
    compare_uint_elements_double("convert_uint16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#ifdef cl_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const long min_expected = (long)(LONG_MIN > -DBL_MAX) ? LONG_MIN : (long)-DBL_MAX;
    const long max_expected = (long)(LONG_MAX < DBL_MAX) ? LONG_MAX : (long)DBL_MAX;
    union { long16 value; long raw[16]; } expected, actual;
    expected.value = ((long16)((long)double_rounded_values[i]));
    actual.value = convert_long16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_double("convert_long16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat((double16)sat_input);
    compare_long_elements_double("convert_long16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rte[i]));
    actual.value = convert_long16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_double("convert_long16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rte((double16)sat_input);
    compare_long_elements_double("convert_long16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rtz[i]));
    actual.value = convert_long16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_double("convert_long16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtz((double16)sat_input);
    compare_long_elements_double("convert_long16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rtp[i]));
    actual.value = convert_long16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_double("convert_long16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtp((double16)sat_input);
    compare_long_elements_double("convert_long16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((long16)((long)double_rounded_values_rtn[i]));
    actual.value = convert_long16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (long)((long)0 - (long)1) >= (long)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (long)0;
        actual.raw[n] = (long)0;
      }
    }
    compare_long_elements_double("convert_long16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (long16)convert_long_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (long16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (long16)max_expected;
    }
    actual.value = convert_long16_sat_rtn((double16)sat_input);
    compare_long_elements_double("convert_long16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#endif

#ifdef cl_khr_int64

#ifdef cl_khr_fp64

  for (size_t i = 0; i < double_values_length; ++i) {
    const double sat_input = (double_values[i] + double_sat_offsets[i]);
    // use the destination (integer) type always to avoid rounding errors when
    // comparing floats to int
    const ulong min_expected = (ulong)(0 > -DBL_MAX) ? 0 : (ulong)-DBL_MAX;
    const ulong max_expected = (ulong)(ULONG_MAX < DBL_MAX) ? ULONG_MAX : (ulong)DBL_MAX;
    union { ulong16 value; ulong raw[16]; } expected, actual;
    expected.value = ((ulong16)((ulong)double_rounded_values[i]));
    actual.value = convert_ulong16((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = double_rounded_values[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_double("convert_ulong16(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat((double16)sat_input);
    compare_ulong_elements_double("convert_ulong16_sat(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rte[i]));
    actual.value = convert_ulong16_rte((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = double_rounded_values_rte[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_double("convert_ulong16_rte(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rte(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rte((double16)sat_input);
    compare_ulong_elements_double("convert_ulong16_sat_rte(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rtz[i]));
    actual.value = convert_ulong16_rtz((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = double_rounded_values_rtz[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_double("convert_ulong16_rtz(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtz(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtz((double16)sat_input);
    compare_ulong_elements_double("convert_ulong16_sat_rtz(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rtp[i]));
    actual.value = convert_ulong16_rtp((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = double_rounded_values_rtp[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_double("convert_ulong16_rtp(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtp(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtp((double16)sat_input);
    compare_ulong_elements_double("convert_ulong16_sat_rtp(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
    expected.value = ((ulong16)((ulong)double_rounded_values_rtn[i]));
    actual.value = convert_ulong16_rtn((double16)double_values[i]);
    for (size_t n=0; n<16; ++n) {
      bool type_is_unsigned = (ulong)((ulong)0 - (ulong)1) >= (ulong)0;
      bool result_is_negative = double_rounded_values_rtn[i] < (double)0;
      if (type_is_unsigned && result_is_negative) {
        // Ignore this result
        expected.raw[n] = (ulong)0;
        actual.raw[n] = (ulong)0;
      }
    }
    compare_ulong_elements_double("convert_ulong16_rtn(double16)", i, &double_values[i], 0, expected.raw, actual.raw, 16);
    expected.value = (ulong16)convert_ulong_rtn(sat_input);
    if (sat_input <= (double)min_expected) {
       expected.value = (ulong16)min_expected;
    }
    else if (sat_input >= (double)max_expected) {
       expected.value = (ulong16)max_expected;
    }
    actual.value = convert_ulong16_sat_rtn((double16)sat_input);
    compare_ulong_elements_double("convert_ulong16_sat_rtn(double16)", i, 0, &sat_input, expected.raw, actual.raw, 16);
  }

#endif

#endif

union { int8 value; int raw[8]; } qe, qa;
union { float8 value; float raw[8]; } qo;

qo.value = (float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f);
qa.value = convert_int8_rtz(qo.value);
qe.value = (int8)(-23, -23, -23, -23, 23, 23, 23, 23);
compare_int_elements_float("convert_int8_rtz(float8)", 0, 0, qo.raw, qe.raw, qa.raw, 8);

qo.value = (float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f);
qa.value = convert_int8_rtp(qo.value);
qe.value = (int8)(-23, -23, -23, -23, 23, 24, 24, 24);
compare_int_elements_float("convert_int8_rtp(float8)", 0, 0, qo.raw, qe.raw, qa.raw, 8);

qo.value = (float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f);
qa.value = convert_int8_rtn(qo.value);
qe.value = (int8)(-24, -24, -24, -23, 23, 23, 23, 23);
compare_int_elements_float("convert_int8_rtn(float8)", 0, 0, qo.raw, qe.raw, qa.raw, 8);

qo.value = (float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f);
qa.value = convert_int8_rte(qo.value);
qe.value = (int8)(-24, -24, -23, -23, 23, 23, 24, 24);
compare_int_elements_float("convert_int8_rte(float8)", 0, 0, qo.raw, qe.raw, qa.raw, 8);

qo.value = (float8)(-23.67f, -23.50f, -23.35f, -23.0f, 23.0f, 23.35f, 23.50f, 23.67f);
qa.value = convert_int8(qo.value);
qe.value = (int8)(-23, -23, -23, -23, 23, 23, 23, 23);
compare_int_elements_float("convert_int8(float8)", 0, 0, qo.raw, qe.raw, qa.raw, 8);

}
